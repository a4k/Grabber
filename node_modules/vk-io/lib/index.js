'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var nodeUtil = _interopDefault(require('util'));
var nodeUrl = _interopDefault(require('url'));
var fetch = _interopDefault(require('node-fetch'));
var createDebug = _interopDefault(require('debug'));
var toughCookie = _interopDefault(require('tough-cookie'));
var cheerio = _interopDefault(require('cheerio'));
var nodeStream = _interopDefault(require('stream'));
var sandwichStream = _interopDefault(require('sandwich-stream'));
var nodeFs = _interopDefault(require('fs'));
var nodeCrypto = _interopDefault(require('crypto'));
var nodeHttp = _interopDefault(require('http'));
var nodeHttps = _interopDefault(require('https'));
var WebSocket = _interopDefault(require('ws'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Creates a key and value from the keys
 *
 * @param {string[]} keys
 *
 * @return {Object}
 */
const keyMirror = keys => {
  const out = {};

  for (const key of keys) {
    out[key] = key;
  }

  return out;
};
/**
 * Returns method for execute
 *
 * @param {string} method
 * @param {Object} params
 *
 * @return {string}
 */

const getExecuteMethod = (method, params = {}) => {
  const options = {};

  for (const [key, value] of Object.entries(params)) {
    if (typeof value === 'object') {
      options[key] = String(value);
      continue;
    }

    options[key] = value;
  }

  return `API.${method}(${JSON.stringify(options)})`;
};
/**
 * Returns chain for execute
 *
 * @param {Array} methods
 *
 * @return {string}
 */

const getChainReturn = methods => `return [${methods.join(',')}];`;
/**
 * Resolve task
 *
 * @param {Array} tasks
 * @param {Array} results
 */

const resolveExecuteTask = (tasks, result) => {
  let errors = 0;
  result.response.forEach((response, i) => {
    if (response !== false) {
      tasks[i].resolve(response);
      return;
    }

    tasks[i].reject(result.errors[errors]);
    errors += 1;
  });
};
/**
 * Returns random ID
 *
 * @return {number}
 */

const getRandomId = () => `${Math.floor(Math.random() * 1e4)}${Date.now()}`;
/**
 * Returns the URL of a small photo
 *
 * @param {Object} photo
 *
 * @return {string}
 */

const getSmallPhoto = photo => photo.photo_130 || photo.photo_75;
/**
 * Returns the URL of a medium photo
 *
 * @param {Object} photo
 *
 * @return {string}
 */

const getMediumPhoto = photo => photo.photo_807 || photo.photo_604 || getSmallPhoto(photo);
/**
 * Returns the URL of a large photo
 *
 * @param {Object} photo
 *
 * @return {string}
 */

const getLargePhoto = photo => photo.photo_2560 || photo.photo_1280 || getMediumPhoto(photo);
/**
 * Delay N-ms
 *
 * @param {number} delayed
 *
 * @return {Promise}
 */

const delay = delayed => new Promise(resolve => setTimeout(resolve, delayed));

const {
  inspect
} = nodeUtil;
class Request {
  /**
   * Constructor
   *
   * @param {string} method
   * @param {Object} params
   */
  constructor(method, params = {}) {
    this.method = method;
    this.params = params;
    this.attempts = 0;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Request';
  }
  /**
   * Adds attempt
   *
   * @return {number}
   */


  addAttempt() {
    this.attempts += 1;
  }
  /**
   * Returns string to execute
   *
   * @return {string}
   */


  toString() {
    return getExecuteMethod(this.method, this.params);
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      method,
      params,
      promise
    } = this;
    const payload = {
      method,
      params,
      promise
    };
    return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
  }

}

/**
 * List methods VK
 * Last updated 21.02.2018
 *
 * @type {Array}
 */
var methods = [
/**
 * Account
 * Methods for working with your account
 */
'account.banUser', 'account.changePassword', 'account.getActiveOffers', 'account.getAppPermissions', 'account.getBanned', 'account.getCounters', 'account.getInfo', 'account.getProfileInfo', 'account.getPushSettings', 'account.lookupContacts', 'account.registerDevice', 'account.saveProfileInfo', 'account.setInfo', 'account.setNameInMenu', 'account.setOffline', 'account.setOnline', 'account.setPushSettings', 'account.setSilenceMode', 'account.unbanUser', 'account.unregisterDevice',
/**
 * Ads
 * API for working with an advertising cabinet VK
 */
'ads.addOfficeUsers', 'ads.checkLink', 'ads.createAds', 'ads.createCampaigns', 'ads.createClients', 'ads.createTargetGroup', 'ads.deleteAds', 'ads.deleteCampaigns', 'ads.deleteClients', 'ads.deleteTargetGroup', 'ads.getAccounts', 'ads.getAds', 'ads.getAdsLayout', 'ads.getAdsTargeting', 'ads.getBudget', 'ads.getCampaigns', 'ads.getCategories', 'ads.getClients', 'ads.getDemographics', 'ads.getFloodStats', 'ads.getOfficeUsers', 'ads.getPostsReach', 'ads.getRejectionReason', 'ads.getStatistics', 'ads.getSuggestions', 'ads.getTargetGroups', 'ads.getTargetingStats', 'ads.getUploadURL', 'ads.getVideoUploadURL', 'ads.importTargetContacts', 'ads.removeOfficeUsers', 'ads.updateAds', 'ads.updateCampaigns', 'ads.updateClients', 'ads.updateTargetGroup',
/**
 * Apps
 * Methods for working with applications
 */
'apps.deleteAppRequests', 'apps.get', 'apps.getCatalog', 'apps.getFriendsList', 'apps.getLeaderboard', 'apps.getScore', 'apps.sendRequest',
/**
 * Audio
 * Methods for working with audio
 */
'audio.get', 'audio.getById', 'audio.getLyrics', 'audio.search', 'audio.getUploadServer', 'audio.save', 'audio.add', 'audio.delete', 'audio.edit', 'audio.reorder', 'audio.restore', 'audio.getAlbums', 'audio.addAlbum', 'audio.editAlbum', 'audio.deleteAlbum', 'audio.moveToAlbum', 'audio.setBroadcast', 'audio.getBroadcastList', 'audio.getRecommendations', 'audio.getPopular', 'audio.getCount',
/**
 * Auth
 * Methods for working with authorization
 */
'auth.checkPhone', 'auth.confirm', 'auth.restore', 'auth.signup',
/**
 * Board
 * Methods for working with discussions
 */
'board.addTopic', 'board.closeTopic', 'board.createComment', 'board.deleteComment', 'board.deleteTopic', 'board.editComment', 'board.editTopic', 'board.fixTopic', 'board.getComments', 'board.getTopics', 'board.openTopic', 'board.restoreComment', 'board.unfixTopic',
/**
 * Database
 * Access to the database of educational institutions VK
 */
'database.getChairs', 'database.getCities', 'database.getCitiesById', 'database.getCountries', 'database.getCountriesById', 'database.getFaculties', 'database.getRegions', 'database.getSchoolClasses', 'database.getSchools', 'database.getStreetsById', 'database.getUniversities',
/**
 * Docs
 * Methods for working with documents
 */
'docs.add', 'docs.delete', 'docs.edit', 'docs.get', 'docs.getById', 'docs.getTypes', 'docs.getUploadServer', 'docs.getMessagesUploadServer', 'docs.getWallUploadServer', 'docs.save', 'docs.search',
/**
 * Fave
 * Methods for working with bookmarks
 */
'fave.addGroup', 'fave.addLink', 'fave.addUser', 'fave.getLinks', 'fave.getMarketItems', 'fave.getPhotos', 'fave.getPosts', 'fave.getUsers', 'fave.getVideos', 'fave.removeGroup', 'fave.removeLink', 'fave.removeUser',
/**
 * Friends
 * Methods for working with friends
 */
'friends.add', 'friends.addList', 'friends.areFriends', 'friends.delete', 'friends.deleteAllRequests', 'friends.deleteList', 'friends.edit', 'friends.editList', 'friends.get', 'friends.getAppUsers', 'friends.getByPhones', 'friends.getLists', 'friends.getMutual', 'friends.getOnline', 'friends.getRecent', 'friends.getRequests', 'friends.getSuggestions', 'friends.search',
/**
 * Gifts
 * Methods for working with gifts
 */
'gifts.get',
/* Unofficially */
'gifts.send', 'gifts.getCatalog',
/**
 * Groups
 * Methods for working with communities
 */
'groups.addCallbackServer', 'groups.addLink', 'groups.approveRequest', 'groups.banUser', 'groups.create', 'groups.deleteCallbackServer', 'groups.deleteLink', 'groups.disableOnline', 'groups.edit', 'groups.editLink', 'groups.editManager', 'groups.editPlace', 'groups.enableOnline', 'groups.get', 'groups.getBanned', 'groups.getById', 'groups.getCallbackConfirmationCode', 'groups.getCallbackSettings', 'groups.getCatalog', 'groups.getCatalogInfo', 'groups.getInvitedUsers', 'groups.getInvites', 'groups.getLongPollServer', 'groups.getLongPollSettings', 'groups.getMembers', 'groups.getOnlineStatus', 'groups.getRequests', 'groups.getSettings', 'groups.getTokenPermissions', 'groups.invite', 'groups.isMember', 'groups.join', 'groups.leave', 'groups.removeUser', 'groups.reorderLink', 'groups.search', 'groups.setCallbackSettings', 'groups.setLongPollSettings', 'groups.unbanUser',
/**
 * Leads
 * Management of advertising actions (offers)
 */
'leads.checkUser', 'leads.complete', 'leads.getStats', 'leads.getUsers', 'leads.metricHit', 'leads.start',
/**
 * Likes
 * Methods for working with the "I like"
 */
'likes.add', 'likes.delete', 'likes.getList', 'likes.isLiked',
/**
 * Market
 * Market methods allow you to work with products in communities
 */
'market.add', 'market.addAlbum', 'market.addToAlbum', 'market.createComment', 'market.delete', 'market.deleteAlbum', 'market.deleteComment', 'market.edit', 'market.editAlbum', 'market.editComment', 'market.get', 'market.getAlbumById', 'market.getAlbums', 'market.getById', 'market.getCategories', 'market.getComments', 'market.removeFromAlbum', 'market.reorderAlbums', 'market.reorderItems', 'market.report', 'market.reportComment', 'market.restore', 'market.restoreComment', 'market.search',
/**
 * Messages
 * Methods for working with personal messages
 */
'messages.addChatUser', 'messages.allowMessagesFromGroup', 'messages.createChat', 'messages.delete', 'messages.deleteChatPhoto', 'messages.deleteDialog', 'messages.denyMessagesFromGroup', 'messages.edit', 'messages.editChat', 'messages.get', 'messages.getById', 'messages.getChat', 'messages.getChatUsers', 'messages.getDialogs', 'messages.getHistory', 'messages.getHistoryAttachments', 'messages.getInviteLink', 'messages.getLastActivity', 'messages.getLongPollHistory', 'messages.getLongPollServer', 'messages.pin', 'messages.isMessagesFromGroupAllowed', 'messages.joinChatByInviteLink', 'messages.markAsAnsweredDialog', 'messages.markAsImportant', 'messages.markAsImportantDialog', 'messages.markAsRead', 'messages.removeChatUser', 'messages.restore', 'messages.search', 'messages.searchDialogs', 'messages.send', 'messages.setActivity', 'messages.setChatPhoto', 'messages.unpin',
/**
 * Newsfeed
 * Methods for working with the user's news feed
 */
'newsfeed.addBan', 'newsfeed.deleteBan', 'newsfeed.deleteList', 'newsfeed.get', 'newsfeed.getBanned', 'newsfeed.getComments', 'newsfeed.getLists', 'newsfeed.getMentions', 'newsfeed.getRecommended', 'newsfeed.getSuggestedSources', 'newsfeed.ignoreItem', 'newsfeed.saveList', 'newsfeed.search', 'newsfeed.unignoreItem', 'newsfeed.unsubscribe',
/**
 * Notes
 * Methods for working with notes
 */
'notes.add', 'notes.createComment', 'notes.delete', 'notes.deleteComment', 'notes.edit', 'notes.editComment', 'notes.get', 'notes.getById', 'notes.getComments', 'notes.restoreComment',
/**
 * Notifications
 * Methods for working with notifications
 */
'notifications.get', 'notifications.markAsViewed',
/**
 * Orders
 * Order management completed in applications
 */
'orders.changeState', 'orders.get', 'orders.getAmount', 'orders.getById',
/**
 * Pages
 * Methods for working with wiki pages
 */
'pages.clearCache', 'pages.get', 'pages.getHistory', 'pages.getTitles', 'pages.getVersion', 'pages.parseWiki', 'pages.save', 'pages.saveAccess',
/**
 * Photos
 * Methods for working with photos
 */
'photos.confirmTag', 'photos.copy', 'photos.createAlbum', 'photos.createComment', 'photos.delete', 'photos.deleteAlbum', 'photos.deleteComment', 'photos.edit', 'photos.editAlbum', 'photos.editComment', 'photos.get', 'photos.getAlbums', 'photos.getAlbumsCount', 'photos.getAll', 'photos.getAllComments', 'photos.getById', 'photos.getChatUploadServer', 'photos.getComments', 'photos.getMarketAlbumUploadServer', 'photos.getMarketUploadServer', 'photos.getMessagesUploadServer', 'photos.getNewTags', 'photos.getOwnerCoverPhotoUploadServer', 'photos.getOwnerPhotoUploadServer', 'photos.getTags', 'photos.getUploadServer', 'photos.getUserPhotos', 'photos.getWallUploadServer', 'photos.makeCover', 'photos.move', 'photos.putTag', 'photos.removeTag', 'photos.reorderAlbums', 'photos.reorderPhotos', 'photos.report', 'photos.reportComment', 'photos.restore', 'photos.restoreComment', 'photos.save', 'photos.saveMarketAlbumPhoto', 'photos.saveMarketPhoto', 'photos.saveMessagesPhoto', 'photos.saveOwnerCoverPhoto', 'photos.saveOwnerPhoto', 'photos.saveWallPhoto', 'photos.search',
/**
 * Places
 * Methods for working with places
 */
'places.add', 'places.checkin', 'places.getById', 'places.getCheckins', 'places.getTypes', 'places.search',
/**
 * Polls
 * Methods for working with polls
 */
'polls.addVote', 'polls.create', 'polls.deleteVote', 'polls.edit', 'polls.getById', 'polls.getVoters',
/**
 * Search
 * Methods for working with search
 */
'search.getHints',
/**
 * Secure
 * Administrative Methods
 */
'secure.addAppEvent', 'secure.checkToken', 'secure.getAppBalance', 'secure.getSMSHistory', 'secure.getTransactionsHistory', 'secure.getUserLevel', 'secure.sendNotification', 'secure.sendSMSNotification', 'secure.setCounter', 'secure.setUserLevel',
/**
 * Stats
 * Methods for working with statistics
 */
'stats.get', 'stats.getPostReach', 'stats.trackVisitor',
/**
 * Status
 * Methods for working with status
 */
'status.get', 'status.set',
/**
 * Storage
 * Methods for working with variables in an application
 */
'storage.get', 'storage.getKeys', 'storage.set',
/**
 * Stories
 * Methods for working with stories
 */
'stories.banOwner', 'stories.delete', 'stories.get', 'stories.getBanned', 'stories.getById', 'stories.getPhotoUploadServer', 'stories.getReplies', 'stories.getStats', 'stories.getVideoUploadServer', 'stories.getViewers', 'stories.hideAllReplies', 'stories.hideReply', 'stories.unbanOwner',
/**
 * Streaming
 * Methods for working with the Streaming API
 */
'streaming.getServerUrl', 'streaming.getSettings', 'streaming.getStats', 'streaming.setSettings',
/**
 * Users
 * Methods for working with user data
 */
'users.get', 'users.getFollowers', 'users.getNearby', 'users.getSubscriptions', 'users.isAppUser', 'users.report', 'users.search',
/**
 * Utils
 * Service methods
 */
'utils.checkLink', 'utils.deleteFromLastShortened', 'utils.getLastShortenedLinks', 'utils.getLinkStats', 'utils.getServerTime', 'utils.getShortLink', 'utils.resolveScreenName',
/**
 * Video
 * Methods for working with videos
 */
'video.add', 'video.addAlbum', 'video.addToAlbum', 'video.createComment', 'video.delete', 'video.deleteAlbum', 'video.deleteComment', 'video.edit', 'video.editAlbum', 'video.editComment', 'video.get', 'video.getAlbumById', 'video.getAlbums', 'video.getAlbumsByVideo', 'video.getCatalog', 'video.getCatalogSection', 'video.getComments', 'video.hideCatalogSection', 'video.removeFromAlbum', 'video.reorderAlbums', 'video.reorderVideos', 'video.report', 'video.reportComment', 'video.restore', 'video.restoreComment', 'video.save', 'video.search',
/* Unofficially */
'video.getRecommendedLiveVideos',
/**
 * Wall
 * Methods for working with posts on the wall
 */
'wall.createComment', 'wall.delete', 'wall.deleteComment', 'wall.edit', 'wall.editAdsStealth', 'wall.editComment', 'wall.get', 'wall.getById', 'wall.getComments', 'wall.getReposts', 'wall.pin', 'wall.post', 'wall.postAdsStealth', 'wall.reportComment', 'wall.reportPost', 'wall.repost', 'wall.restore', 'wall.restoreComment', 'wall.search', 'wall.unpin',
/**
 * Widgets
 * Methods for working with widgets on external sites
 */
'widgets.getComments', 'widgets.getPages'];

/**
 * General error class
 *
 * @public
 */
class VKError extends Error {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    code,
    message
  }) {
    super(message);
    this.code = code;
    this.message = message;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns property for json
   *
   * @return {Object}
   */


  toJSON() {
    const json = {};

    for (const key of Object.getOwnPropertyNames(this)) {
      json[key] = this[key];
    }

    return json;
  }

}

var version = "4.0.0-beta.6";

/**
 * VK API version
 *
 * @type {string}
 */

const API_VERSION = '5.74';
/**
 * Chat peer ID
 *
 * @type {number}
 */

const CHAT_PEER = 2e9;
/**
 * Blank html redirect
 *
 * @type {string}
 */

const CALLBACK_BLANK = 'https://oauth.vk.com/blank.html';
/**
 * User-Agent for standalone auth
 *
 * @type {string}
 */

const DESKTOP_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36';
/**
 * Minimum time interval api with error
 *
 * @type {number}
 */

const MINIMUM_TIME_INTERVAL_API = 1133;
/**
 * Default options
 *
 * @type {Object}
 *
 * @property {?string} [token]               Access token
 * @property {Agent}   [agent]               HTTPS agent
 * @property {?string} [lang]                The return data language
 *
 * @property {?string} [login]               User login (phone number or email)
 * @property {?string} [phone]               User phone number
 * @property {?string} [password]            User password
 *
 * @property {?number} [app]                 Application ID
 * @property {?number} [key]                 Secret application key
 * @property {?number} [scope]               List of permissions
 *
 * @property {string}  [apiMode]             Query mode (sequential|parallel|parallel_selected)
 * @property {number}  [apiWait]             Time to wait before re-querying
 * @property {number}  [apiLimit]            Requests per second
 * @property {number}  [apiTimeout]          Wait time for one request
 * @property {number}  [apiHeaders]          Headers sent to the API
 * @property {number}  [apiAttempts]         The number of retries at calling
 * @property {number}  [apiExecuteCount]     Number of requests per execute
 * @property {Array}   [apiExecuteMethods]   Methods for call execute (apiMode=parallel_selected)
 *
 * @property {number}  [uploadTimeout]       Wait time for one request
 *
 * @property {number}  [pollingWait]         Time to wait before re-querying
 * @property {number}  [pollingGroupId]      Group ID for polling
 * @property {number}  [pollingAttempts]     The number of retries at calling
 *
 * @property {?string} [webhookPath]         Webhook path
 * @property {?string} [webhookSecret]       Webhook secret key
 * @property {?string} [webhookConfirmation] Webhook confirmation key
 *
 * @property {number}  [collectAttempts]     The number of retries at calling
 */

const defaultOptions = {
  token: null,
  agent: null,
  lang: null,
  login: null,
  phone: null,
  password: null,
  app: null,
  key: null,
  scope: 'all',
  apiMode: 'sequential',
  apiWait: 3e3,
  apiLimit: 3,
  apiAttempts: 3,
  apiTimeout: 10e3,
  apiHeaders: {
    'User-Agent': `vk-io/${version} (+https://github.com/negezor/vk-io)`
  },
  apiExecuteCount: 25,
  apiExecuteMethods: ['messages.send'],
  uploadTimeout: 20e3,
  pollingWait: 3e3,
  pollingAttempts: 3,
  pollingGroupId: null,
  webhookPath: null,
  webhookSecret: null,
  webhookConfirmation: null,
  collectAttempts: 3
};
/**
 * Default extensions for attachments
 *
 * @type {Object}
 */

const defaultExtensions = {
  photo: 'jpg',
  video: 'mp4',
  audio: 'mp3',
  voice: 'ogg',
  graffiti: 'png'
};
/**
 * Default content type for attachments
 *
 * @type {Object}
 */

const defaultContentTypes = {
  photo: 'image/jpeg',
  video: 'video/mp4',
  audio: 'audio/mp3',
  voice: 'audio/ogg',
  graffiti: 'image/png'
};
/**
 * Sources of captcha
 *
 * @type {Object}
 */

const captchaTypes = keyMirror(['API', 'DIRECT_AUTH', 'IMPLICIT_FLOW_AUTH', 'ACCOUNT_VERIFICATION']);
/**
 * API error codes
 *
 * @type {Object}
 */

const apiErrors = {
  UNKNOWN_ERROR: 1,
  APP_SWITCHED_OFF: 2,
  UNKNOWN_METHOD: 3,
  AUTH_FAILURE: 5,
  TOO_MANY_REQUESTS: 6,
  SCOPE_NEEDED: 7,
  INCORRECT_REQUEST: 8,
  TOO_MANY_SIMILAR_ACTIONS: 9,
  INTERNAL_ERROR: 10,
  RESPONSE_SIZE_TOO_BIG: 13,
  CAPTCHA_REQUIRED: 14,
  ACCESS_DENIED: 15,
  USER_VALIDATION_REQUIRED: 17,
  PAGE_BLOCKED: 18,
  STANDALONE_ONLY: 20,
  STANDALONE_AND_OPEN_API_ONLY: 21,
  METHOD_DISABLED: 23,
  CONFIRMATION_REQUIRED: 24,
  GROUP_TOKEN_NOT_VALID: 27,
  APP_TOKEN_NOT_VALID: 28,
  WRONG_PARAMETER: 100,
  INCORRECT_USER_ID: 113,
  ALBUM_ACCESS_DENIED: 200,
  AUDIO_ACCESS_DENIED: 201,
  GROUP_ACCESS_DENIED: 203,
  ALBUM_OVERFLOW: 300,
  PAYMENTS_DISABLED: 500,
  COMMERCIAL_ACCESS_DENIED: 600,
  COMMERCIAL_ERROR: 603
};
/**
 * Auth error codes
 *
 * @type {Object}
 */

const authErrors = keyMirror(['PAGE_BLOCKED', 'INVALID_PHONE_NUMBER', 'AUTHORIZATION_FAILED', 'FAILED_PASSED_CAPTCHA', 'MISSING_CAPTCHA_HANDLER', 'FAILED_PASSED_TWO_FACTOR', 'MISSING_TWO_FACTOR_HANDLER']);
/**
 * Upload error codes
 *
 * @type {Object}
 */

const uploadErrors = keyMirror(['NO_FILES_TO_UPLOAD', 'EXCEEDED_MAX_FILES', 'UNSUPPORTED_SOURCE_TYPE']);
/**
 * Updates error codes
 *
 * @type {Object}
 */

const updatesErrors = keyMirror(['NEED_RESTART', 'POLLING_REQUEST_FAILED']);
/**
 * Collect error codes
 *
 * @type {Object}
 */

const collectErrors = keyMirror(['EXECUTE_ERROR']);
/**
 * Snippets error codes
 *
 * @type {Object}
 */

const snippetsErrors = keyMirror(['INVALID_URL', 'URL_NOT_ALLOWED', 'RESOURCE_NOT_FOUND']);
/**
 * Updates sources
 *
 * @type {Object}
 */

const updatesSources = keyMirror(['POLLING', 'WEBHOOK']);
/**
 * List of user permissions and their bit mask
 *
 * @type {Map}
 */

const userScopes = new Map([['notify', 1], ['friends', 2], ['photos', 4], ['audio', 8], ['video', 16], ['pages', 128], ['link', 256], ['status', 1024], ['notes', 2048], ['messages', 4096], ['wall', 8192], ['ads', 32768], ['offline', 65536], ['docs', 131072], ['groups', 262144], ['notifications', 524288], ['stats', 1048576], ['email', 4194304], ['market', 134217728]]);
/**
 * List of group permissions and their bit mask
 *
 * @type {Map}
 */

const groupScopes = new Map([['stories', 1], ['photos', 4], // ['app_widget', 64],
['messages', 4096], ['docs', 131072], ['manage', 262144]]);
/**
 * VK Platforms
 *
 * @type {Map}
 */

const platforms = new Map([[1, 'mobile'], [2, 'iphone'], [3, 'ipad'], [4, 'android'], [5, 'wphone'], [6, 'windows'], [7, 'web'], [8, 'standalone']]);
/**
 * Parse attachments with RegExp
 *
 * @type {RegExp}
 */

const parseAttachment = /(photo|video|audio|doc|wall|market)([-\d]+)_(\d+)_?(\d+)?/;
/**
 * Parse resource with RegExp
 *
 * @type {RegExp}
 */

const parseResource = /(app(?:lication)|id|club|public|albums|tag)([-\d]+)/;
/**
 * Parse owner resource with RegExp
 *
 * @type {RegExp}
 */

const parseOwnerResource = /(album|topic|wall|page|videos)([-\d]+)_(\d+)/;

const {
  CAPTCHA_REQUIRED,
  USER_VALIDATION_REQUIRED,
  CONFIRMATION_REQUIRED
} = apiErrors;
class APIError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor(payload) {
    const code = Number(payload.error_code);
    const message = `Code №${code} - ${payload.error_msg}`;
    super({
      code,
      message
    });
    this.params = payload.request_params;

    if (code === CAPTCHA_REQUIRED) {
      this.captchaSid = Number(payload.captcha_sid);
      this.captchaImg = payload.captcha_img;
    } else if (code === USER_VALIDATION_REQUIRED) {
      this.redirectUri = payload.redirect_uri;
    } else if (code === CONFIRMATION_REQUIRED) {
      this.confirmationText = payload.confirmation_text;
    }
  }

}

class AuthError extends VKError {}

class UploadError extends VKError {}

class CollectError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    message,
    code,
    errors
  }) {
    super({
      message,
      code
    });
    this.errors = errors;
  }

}

class UpdatesError extends VKError {}

class ExecuteError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor(payload) {
    const code = Number(payload.error_code);
    const message = `Code №${code} - ${payload.error_msg}`;
    super({
      code,
      message
    });
    this.method = payload.method;
  }

}

class SnippetsError extends VKError {}

class StreamingRuleError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    message,
    error_code: code
  }) {
    super({
      message,
      code
    });
  }

}

const {
  URL
} = nodeUrl;
/**
 * Returns the entire permission bit mask
 *
 * @return {number}
 */

const getAllUsersPermissions = () => Array.from(userScopes.values()).reduce((previous, current) => previous + current, 0);
/**
 * Returns the entire permission bit mask
 *
 * @return {number}
 */

const getAllGroupsPermissions = () => Array.from(groupScopes.values()).reduce((previous, current) => previous + current, 0);
/**
 * Returns the bit mask of the user permission by name
 *
 * @param {Array|string} scope
 *
 * @return {number}
 */

const getUsersPermissionsByName = scope => {
  if (!Array.isArray(scope)) {
    scope = scope.split(/,\s{0,}/);
  }

  let bitMask = 0;

  for (const name of scope) {
    if (userScopes.has(name)) {
      bitMask += userScopes.get(name);
    }
  }

  return bitMask;
};
/**
 * Returns the bit mask of the group permission by name
 *
 * @param {Array|string} scope
 *
 * @return {number}
 */

const getGroupsPermissionsByName = scope => {
  if (!Array.isArray(scope)) {
    scope = scope.split(/,\s{0,}/);
  }

  let bitMask = 0;

  for (const name of scope) {
    if (groupScopes.has(name)) {
      bitMask += groupScopes.get(name);
    }
  }

  return bitMask;
};
/**
 * Parse form
 *
 * @param {Cheerio} $
 *
 * @return {Object}
 */

const parseFormField = $ => {
  const $form = $('form[action][method]');
  const fields = {};

  for (const _ref of $form.serializeArray()) {
    const {
      name,
      value
    } = _ref;
    fields[name] = value;
  }

  return {
    action: $form.attr('action'),
    fields
  };
};
/**
 * Returns full URL use Response
 *
 * @param {string}   action
 * @param {Response} response
 *
 * @type {URL}
 */

const getFullURL = (action, {
  url
}) => {
  if (action.startsWith('https://')) {
    return new URL(action);
  }

  const {
    protocol,
    host
  } = new URL(url);
  return new URL(action, `${protocol}//${host}`);
};

const {
  promisify
} = nodeUtil;
const debug = createDebug('vk-io:util:fetch-cookie');
const REDIRECT_CODES = [303, 301, 302];
const {
  CookieJar
} = toughCookie;
const fetchCookieDecorator = (jar = new CookieJar()) => {
  const setCookie = promisify(jar.setCookie).bind(jar);
  const getCookieString = promisify(jar.getCookieString).bind(jar);
  return async function fetchCookie(url, options = {}) {
    const previousCookie = await getCookieString(url);
    const {
      headers = {}
    } = options;

    if (previousCookie) {
      headers.cookie = previousCookie;
    }

    debug('fetch url %s', url);
    const response = await fetch(url, _objectSpread({}, options, {
      headers
    }));
    const cookies = response.headers.raw()['set-cookie'] || [];

    if (cookies.length === 0) {
      return response;
    }

    await Promise.all(cookies.map(cookie => setCookie(cookie, response.url)));
    return response;
  };
};
const fetchCookieFollowRedirectsDecorator = jar => {
  const fetchCookie = fetchCookieDecorator(jar);
  return async function fetchCookieFollowRedirects(url, options = {}) {
    const response = await fetchCookie(url, _objectSpread({}, options, {
      redirect: 'manual'
    }));
    const isRedirect = REDIRECT_CODES.includes(response.status);

    if (isRedirect && options.redirect !== 'manual' && options.follow !== 0) {
      debug('Redirect to', response.headers.get('location'));
      let follow;

      if (options.follow) {
        follow = options.follow - 1;
      }

      return await fetchCookieFollowRedirects(response.headers.get('location'), {
        method: 'GET',
        body: null,
        follow
      });
    }

    return response;
  };
};

const {
  load: cheerioLoad
} = cheerio;
const {
  URL: URL$1,
  URLSearchParams
} = nodeUrl;
const debug$1 = createDebug('vk-io:auth:account-verification');
const {
  INVALID_PHONE_NUMBER,
  AUTHORIZATION_FAILED,
  FAILED_PASSED_CAPTCHA,
  MISSING_CAPTCHA_HANDLER,
  FAILED_PASSED_TWO_FACTOR,
  MISSING_TWO_FACTOR_HANDLER
} = authErrors;
/**
 * Two-factor auth check action
 *
 * @type {string}
 */

const ACTION_AUTH_CODE = 'act=authcheck';
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE = 'act=security';
/**
 * Bind a phone to a page
 *
 * @type {string}
 */

const ACTION_VALIDATE = 'act=validate';
/**
 * Bind a phone to a page action
 *
 * @type {string}
 */

const ACTION_CAPTCHA = 'act=captcha';
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS = 3;
class AccountVerification {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    const {
      agent,
      login,
      phone
    } = vk.options;
    this.agent = agent;
    this.login = login;
    this.phone = phone;
    this.jar = new CookieJar();
    this.fetchCookie = fetchCookieFollowRedirectsDecorator(this.jar);
    this.captcha = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'AccountVerification';
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, _objectSpread({}, options, {
      agent,
      compress: false,
      headers: _objectSpread({}, headers, {
        'User-Agent': DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run(redirectUri) {
    let response = await this.fetch(redirectUri, {
      method: 'GET'
    });
    const isProcessed = true;

    while (isProcessed) {
      const {
        url
      } = response;

      if (url.includes(CALLBACK_BLANK)) {
        let {
          hash
        } = new URL$1(response.url);

        if (hash.startsWith('#')) {
          hash = hash.substring(1);
        }

        const params = new URLSearchParams(hash);

        if (params.has('error')) {
          throw new AuthError({
            message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
            code: AUTHORIZATION_FAILED
          });
        }

        const user = params.get('user_id');
        return {
          user: user !== null ? Number(user) : null,
          token: params.get('access_token')
        };
      }

      const $ = cheerioLoad((await response.text()));

      if (url.includes(ACTION_AUTH_CODE)) {
        response = await this.processTwoFactorForm(response, $);
        continue;
      }

      if (url.includes(ACTION_SECURITY_CODE)) {
        response = await this.processSecurityForm(response, $);
        continue;
      }

      if (url.includes(ACTION_VALIDATE)) {
        response = await this.processValidateForm(response, $);
        continue;
      }

      if (url.includes(ACTION_CAPTCHA)) {
        response = await this.processCaptchaForm(response, $);
        continue;
      }

      throw new AuthError({
        message: 'Account verification failed',
        code: AUTHORIZATION_FAILED
      });
    }
  }
  /**
   * Process two-factor form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processTwoFactorForm(response, $) {
    debug$1('process two-factor handle');

    if (this.vk.twoFactorHandler === null) {
      throw new AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER
      });
    }

    let isProcessed = true;

    while (this.twoFactorAttempts < TWO_FACTOR_ATTEMPTS && isProcessed) {
      // eslint-disable-next-line no-loop-func
      await new Promise((resolve, reject) => {
        this.vk.twoFactorHandler({}, async code => {
          const {
            action,
            fields
          } = parseFormField($);
          fields.code = code;

          try {
            const url = getFullURL(action, response);
            response = await this.fetch(url, {
              method: 'POST',
              body: new URLSearchParams(fields)
            });
          } catch (error) {
            reject(error);
            throw error;
          }

          if (response.url.includes(ACTION_AUTH_CODE)) {
            resolve();
            throw new AuthError({
              message: 'Incorrect two-factor code',
              code: FAILED_PASSED_TWO_FACTOR
            });
          }

          isProcessed = false;
          resolve();
        });
      });
      this.twoFactorAttempts += 1;
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS && isProcessed) {
      throw new AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR
      });
    }

    return response;
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug$1('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = parseFormField($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = getFullURL(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE)) {
      throw new AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER
      });
    }

    return response;
  }
  /**
   * Process validation form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processValidateForm(response, $) {
    const href = $('#activation_wrap a').attr('href');
    const url = getFullURL(href, response);
    return await this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Process captcha form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processCaptchaForm(response, $) {
    if (this.vk.captchaHandler === null) {
      throw new AuthError({
        message: 'Missing captcha handler',
        code: MISSING_CAPTCHA_HANDLER
      });
    }

    if (this.captcha !== null) {
      this.captcha.reject(new AuthError({
        message: 'Incorrect captcha code',
        code: FAILED_PASSED_CAPTCHA
      }));
      this.captcha = null;
      this.captchaAttempts += 1;
    }

    const {
      action,
      fields
    } = parseFormField($);
    const src = $('.captcha_img').attr('src');
    const payload = {
      type: captchaTypes.ACCOUNT_VERIFICATION,
      sid: fields.captcha_sid,
      src
    };
    await new Promise((resolveCaptcha, rejectCaptcha) => {
      this.vk.captchaHandler(payload, key => new Promise((resolve, reject) => {
        if (key instanceof Error) {
          rejectCaptcha(key);
          reject(key);
          return;
        }

        fields.captcha_key = key;
        this.captcha = {
          resolve,
          reject
        };
        resolveCaptcha();
      }));
    });
    const url = getFullURL(action, response);
    url.searchParams.set('utf8', 1);
    return await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams(fields)
    });
  }

}

function sequential(next) {
  this.callMethod(this.queue.shift());
  next();
}

async function parallel(next) {
  const {
    queue
  } = this;

  if (queue[0].method.startsWith('execute')) {
    sequential.call(this, next);
    return;
  } // Wait next event loop, saves one request or more


  await delay(0);
  const {
    apiExecuteCount
  } = this.vk.options;
  const tasks = [];
  const chain = [];

  for (let i = 0; i < queue.length; i += 1) {
    if (queue[i].method.startsWith('execute')) {
      continue;
    }

    const request = queue.splice(i, 1)[0];
    i -= 1;
    tasks.push(request);
    chain.push(String(request));

    if (tasks.length >= apiExecuteCount) {
      break;
    }
  }

  try {
    const request = new Request('execute', {
      code: getChainReturn(chain)
    });
    next();
    this.callMethod(request);
    resolveExecuteTask(tasks, (await request.promise));
  } catch (error) {
    for (const task of tasks) {
      task.reject(error);
    }
  }
}

async function parallelSelected(next) {
  const {
    apiExecuteMethods,
    apiExecuteCount
  } = this.vk.options;
  const {
    queue
  } = this;

  if (!apiExecuteMethods.includes(queue[0].method)) {
    sequential.call(this, next);
    return;
  } // Wait next event loop, saves one request or more


  await delay(0);
  const tasks = [];
  const chain = [];

  for (let i = 0; i < queue.length; i += 1) {
    if (!apiExecuteMethods.includes(queue[i].method)) {
      continue;
    }

    const request = queue.splice(i, 1)[0];
    i -= 1;
    tasks.push(request);
    chain.push(String(request));

    if (tasks.length >= apiExecuteCount) {
      break;
    }
  }

  if (tasks.length === 0) {
    sequential.call(this, next);
    return;
  }

  try {
    const request = new Request('execute', {
      code: getChainReturn(chain)
    });
    next();
    this.callMethod(request);
    resolveExecuteTask(tasks, (await request.promise));
  } catch (error) {
    for (const task of tasks) {
      task.reject(error);
    }
  }
}

const {
  inspect: inspect$1
} = nodeUtil;
const {
  URL: URL$2,
  URLSearchParams: URLSearchParams$1
} = nodeUrl;
const {
  CAPTCHA_REQUIRED: CAPTCHA_REQUIRED$1,
  TOO_MANY_REQUESTS,
  USER_VALIDATION_REQUIRED: USER_VALIDATION_REQUIRED$1
} = apiErrors;
const debug$2 = createDebug('vk-io:api');
/**
 * Working with API methods
 *
 * @public
 */

class API {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.queue = [];
    this.started = false;
    this.suspended = false;

    for (const method of methods) {
      const [group, name] = method.split('.');

      if (!(group in this)) {
        this[group] = {};
      }

      this[group][name] = params => this.enqueue(method, params);
    }

    this.messages.send = (params = {}) => {
      if (!('random_id' in params)) {
        params.random_id = getRandomId();
      }

      return this.enqueue('messages.send', params);
    };
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'API';
  }
  /**
   * Returns the current used API version
   *
   * @return {string}
   */


  get API_VERSION() {
    return API_VERSION;
  }
  /**
   * Checks that this is a API method
   *
   * @param {string} method
   *
   * @return {boolean}
   */


  isMethod(method) {
    return methods.includes(method);
  }
  /**
   * Call execute method
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  execute(params) {
    return this.enqueue('execute', params);
  }
  /**
   * Call execute procedure
   *
   * @param {string} name
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  procedure(name, params) {
    return this.enqueue(`execute.${name}`, params);
  }
  /**
   * Call raw method
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  call(method, params) {
    return this.enqueue(method, params);
  }
  /**
   * Adds request for queue
   *
   * @param {Request} request
   *
   * @return {Promise<Object>}
   */


  callWithRequest(request) {
    this.queue.push(request);
    this.worker();
    return request.promise;
  }
  /**
   * Adds method to queue
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  enqueue(method, params) {
    const request = new Request(method, params);
    return this.callWithRequest(request);
  }
  /**
   * Adds an element to the beginning of the queue
   *
   * @param {Request} request
   */


  requeue(request) {
    this.queue.unshift(request);
    this.worker();
  }
  /**
   * Running queue
   */


  worker() {
    if (this.started) {
      return;
    }

    this.started = true;
    const {
      apiLimit,
      apiMode,
      apiExecuteCount
    } = this.vk.options;
    const interval = Math.round(MINIMUM_TIME_INTERVAL_API / apiLimit);
    const handler = this.getRequestHandler(apiMode);

    const work = async () => {
      if (this.queue.length === 0 || this.suspended) {
        this.started = false;
        return;
      }

      handler.call(this, () => {
        setTimeout(work, interval);
      });
    };

    work();
  }
  /**
   * Calls the api method
   *
   * @param {Object} request
   */


  async callMethod(request) {
    const {
      token,
      lang,
      agent,
      apiTimeout,
      apiHeaders
    } = this.vk.options;
    const {
      method
    } = request;

    try {
      const url = new URL$2(method, 'https://api.vk.com/method/');
      url.searchParams.set('access_token', token);
      url.searchParams.set('v', API_VERSION);

      if (lang !== null) {
        url.searchParams.append('lang', lang);
      }

      debug$2(`http --> ${method}`);
      const startTime = Date.now();
      let response = await fetch(url, {
        agent,
        method: 'POST',
        compress: false,
        timeout: apiTimeout,
        headers: _objectSpread({}, apiHeaders, {
          connection: 'keep-alive'
        }),
        body: new URLSearchParams$1(request.params)
      });
      response = await response.json();
      const endTime = (Date.now() - startTime).toLocaleString();
      debug$2(`http <-- ${method} ${endTime}ms`);

      if ('error' in response) {
        this.handleError(request, new APIError(response.error));
        return;
      }

      if ('captcha' in request) {
        request.captcha.resolve();
      }

      if (method.startsWith('execute')) {
        request.resolve({
          response: response.response,
          errors: (response.execute_errors || []).map(error => new ExecuteError(error))
        });
        return;
      }

      request.resolve('response' in response ? response.response : response);
    } catch (error) {
      const {
        apiWait,
        apiAttempts
      } = this.vk.options;

      if (request.addAttempt() <= apiAttempts) {
        setTimeout(() => {
          debug$2(`Request ${method} restarted ${request.attempts} times`);
          this.requeue(request);
        }, apiWait);
        return;
      }

      if ('captcha' in request) {
        request.captcha.reject(error);
      }

      request.reject(error);
    }
  }
  /**
   * Error API handler
   *
   * @param {Request} request
   * @param {Object} error
   */


  async handleError(request, error) {
    const {
      code
    } = error;

    if (code === TOO_MANY_REQUESTS) {
      if (this.suspended) {
        this.requeue(request);
        return;
      }

      this.suspended = true;
      await delay(MINIMUM_TIME_INTERVAL_API / this.vk.options.apiLimit + 50);
      this.suspended = false;
      this.requeue(request);
      return;
    }

    if ('captcha' in request) {
      request.captcha.reject(error);
    }

    if (code === USER_VALIDATION_REQUIRED$1) {
      if (this.suspended) {
        this.requeue(request);
      }

      this.suspended = true;

      try {
        const verification = new AccountVerification(this.vk);
        const {
          token
        } = await verification.run(error.redirectUri);
        debug$2('Account verification passed');
        this.vk.setToken(token);
        this.suspended = false;
        this.requeue(request);
      } catch (verificationError) {
        debug$2('Account verification error', verificationError);
        request.reject(error);
        await delay(15e3);
        this.suspended = false;
        this.worker();
      }

      return;
    }

    const isCaptcha = code === CAPTCHA_REQUIRED$1;

    if (isCaptcha && this.vk.captchaHandler === null || !isCaptcha) {
      request.reject(error);
      return;
    }

    const {
      captchaSid
    } = error;
    const payload = {
      type: captchaTypes.API,
      src: error.captchaImg,
      sid: captchaSid,
      request
    };
    this.vk.captchaHandler(payload, key => new Promise((resolve, reject) => {
      if (key instanceof Error) {
        request.reject(key);
        reject(key);
        return;
      }

      request.params.captcha_sid = captchaSid;
      request.params.captcha_key = key;
      request.captcha = {
        resolve,
        reject
      };
      this.requeue(request);
    }));
  }
  /**
   * Returns request handler
   *
   * @param {string} mode
   *
   * @return {Function}
   */


  getRequestHandler(mode = 'sequential') {
    switch (mode) {
      case 'sequential':
        {
          return sequential;
        }

      case 'parallel':
        {
          return parallel;
        }

      case 'parallel_selected':
        {
          return parallelSelected;
        }

      default:
        throw new Error('Unsuported api mode');
    }
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$1.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      queue
    } = this;
    const payload = {
      started,
      queue
    };
    return `${options.stylize(name, 'special')} ${inspect$1(payload, options)}`;
  }

}

const {
  load: cheerioLoad$1
} = cheerio;
const {
  URL: URL$3,
  URLSearchParams: URLSearchParams$2
} = nodeUrl;
const debug$3 = createDebug('vk-io:auth:direct');
const {
  PAGE_BLOCKED,
  INVALID_PHONE_NUMBER: INVALID_PHONE_NUMBER$1,
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$1,
  FAILED_PASSED_CAPTCHA: FAILED_PASSED_CAPTCHA$1,
  MISSING_CAPTCHA_HANDLER: MISSING_CAPTCHA_HANDLER$1,
  FAILED_PASSED_TWO_FACTOR: FAILED_PASSED_TWO_FACTOR$1,
  MISSING_TWO_FACTOR_HANDLER: MISSING_TWO_FACTOR_HANDLER$1
} = authErrors;
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS$1 = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */

const CAPTCHA_ATTEMPTS$1 = 3;
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE$1 = 'act=security';
class DirectAuth {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, {
    app = vk.options.app,
    key = vk.options.key,
    agent = vk.options.agent,
    scope = vk.options.scope,
    login = vk.options.login,
    phone = vk.options.phone,
    password = vk.options.password
  } = {}) {
    this.vk = vk;
    this.app = app;
    this.key = key;
    this.agent = agent;
    this.scope = scope;
    this.login = login;
    this.phone = phone;
    this.password = password;
    this.started = false;
    this.captcha = null;
    this.twoFactor = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'DirectAuth';
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, _objectSpread({}, options, {
      agent,
      compress: false,
      headers: _objectSpread({}, headers, {
        'User-Agent': DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Returns permission page
   *
   * @param {Object} query
   *
   * @return {Response}
   */


  getPermissionsPage(query = {}) {
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = getAllUsersPermissions();
    } else if (typeof scope !== 'number') {
      scope = getUsersPermissionsByName(scope);
    }

    debug$3('auth scope %s', scope);
    const {
      app,
      key,
      login,
      phone,
      password
    } = this;
    const params = new URLSearchParams$2(_objectSpread({}, query, {
      username: login || phone,
      grant_type: 'password',
      client_secret: key,
      '2fa_supported': this.vk.twoFactorHandler !== null ? 1 : 0,
      v: API_VERSION,
      client_id: app,
      password,
      scope
    }));
    const url = new URL$3(`https://oauth.vk.com/token?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run() {
    if (this.started) {
      throw new AuthError({
        message: 'Authorization already started!',
        code: AUTHORIZATION_FAILED$1
      });
    }

    this.started = true;
    this.fetchCookie = fetchCookieFollowRedirectsDecorator();
    let response = await this.getPermissionsPage();
    let text;
    const isProcessed = true;

    while (isProcessed) {
      text = await response.text();
      let isJSON = true;

      try {
        text = JSON.parse(text);
      } catch (e) {
        isJSON = false;
      }

      if (isJSON && 'access_token' in text) {
        const {
          email = null,
          user_id: user = null,
          expires_in: expires = null,
          access_token: token
        } = text;
        return {
          email,
          user: user !== null ? Number(user) : null,
          token,
          expires: expires !== null ? Number(expires) : null
        };
      } else if (isJSON && 'error' in text) {
        if (text.error === 'invalid_client') {
          throw new AuthError({
            message: `Invalid client (${text.error_description})`,
            code: AUTHORIZATION_FAILED$1
          });
        }

        if (text.error === 'need_captcha') {
          response = await this.processCaptcha(text);
          continue;
        }

        if (text.error === 'need_validation') {
          if ('validation_type' in text) {
            response = await this.processTwoFactor(text);
            continue;
          }

          const $ = cheerioLoad$1(text);
          response = this.processSecurityForm(response, $);
          continue;
        }

        throw new AuthError({
          message: 'Unsupported type validation',
          code: AUTHORIZATION_FAILED$1
        });
      }

      throw new AuthError({
        message: 'Authorization failed',
        code: AUTHORIZATION_FAILED$1
      });
    }
  }
  /**
   * Process captcha
   *
   * @param {Object} payload
   *
   * @return {Response}
   */


  async processCaptcha({
    captcha_sid: sid,
    captcha_img: src
  }) {
    debug$3('captcha process');

    if (this.captcha !== null) {
      this.captcha.reject(new AuthError({
        message: 'Incorrect captcha code',
        code: FAILED_PASSED_CAPTCHA$1
      }));
      this.captcha = null;
      this.captchaAttempts += 1;
    }

    if (this.vk.captchaHandler === null) {
      throw new AuthError({
        message: 'Missing captcha handler',
        code: MISSING_CAPTCHA_HANDLER$1
      });
    }

    if (this.captchaAttempts >= CAPTCHA_ATTEMPTS$1) {
      throw new AuthError({
        message: 'Maximum attempts passage captcha',
        code: FAILED_PASSED_CAPTCHA$1
      });
    }

    const payload = {
      type: captchaTypes.DIRECT_AUTH,
      sid,
      src
    };
    const key = await new Promise((resolveCaptcha, rejectCaptcha) => {
      this.vk.captchaHandler(payload, code => new Promise((resolve, reject) => {
        if (code instanceof Error) {
          rejectCaptcha(code);
          reject(code);
          return;
        }

        this.captcha = {
          resolve,
          reject
        };
        resolveCaptcha(code);
      }));
    });
    return await this.getPermissionsPage({
      captcha_sid: sid,
      captcha_key: key
    });
  }
  /**
   * Process two-factor
   *
   * @param {Object} response
   *
   * @return {Promise<Response>}
   */


  async processTwoFactor({
    validation_type: validationType,
    phone_mask: phoneMask
  }) {
    debug$3('process two-factor handle');

    if (this.twoFactor !== null) {
      this.twoFactor.reject(new AuthError({
        message: 'Incorrect two-factor code',
        code: FAILED_PASSED_TWO_FACTOR$1
      }));
      this.twoFactor = null;
      this.twoFactorAttempts += 1;
    }

    if (this.vk.twoFactorHandler === null) {
      throw new AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER$1
      });
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS$1) {
      throw new AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR$1
      });
    }

    const type = validationType === '2fa_app' ? 'app' : 'sms';
    const key = await new Promise(resolveTwoFactor => {
      this.vk.twoFactorHandler({
        type,
        phoneMask
      }, code => new Promise((resolve, reject) => {
        this.twoFactor = {
          resolve,
          reject
        };
        resolveTwoFactor(code);
      }));
    });
    return await this.getPermissionsPage({
      code: key
    });
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug$3('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER$1
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = parseFormField($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = getFullURL(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams$2(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE$1)) {
      throw new AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER$1
      });
    }

    return response;
  }

}

const {
  load: cheerioLoad$2
} = cheerio;
const {
  URL: URL$4,
  URLSearchParams: URLSearchParams$3
} = nodeUrl;
const {
  promisify: promisify$1
} = nodeUtil;
const debug$4 = createDebug('vk-io:auth:implicit-flow');
const {
  PAGE_BLOCKED: PAGE_BLOCKED$1,
  INVALID_PHONE_NUMBER: INVALID_PHONE_NUMBER$2,
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$2,
  FAILED_PASSED_CAPTCHA: FAILED_PASSED_CAPTCHA$2,
  MISSING_CAPTCHA_HANDLER: MISSING_CAPTCHA_HANDLER$2,
  FAILED_PASSED_TWO_FACTOR: FAILED_PASSED_TWO_FACTOR$2,
  MISSING_TWO_FACTOR_HANDLER: MISSING_TWO_FACTOR_HANDLER$2
} = authErrors;
/**
 * Blocked action
 *
 * @type {string}
 */

const ACTION_BLOCKED = 'act=blocked';
/**
 * Two-factor auth check action
 *
 * @type {string}
 */

const ACTION_AUTH_CODE$1 = 'act=authcheck';
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE$2 = 'act=security';
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS$2 = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */

const CAPTCHA_ATTEMPTS$2 = 3;
class ImplicitFlow {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, {
    app = vk.options.app,
    key = vk.options.key,
    agent = vk.options.agent,
    scope = vk.options.scope,
    login = vk.options.login,
    phone = vk.options.phone,
    password = vk.options.password
  } = {}) {
    this.vk = vk;
    this.app = app;
    this.key = key;
    this.agent = agent;
    this.scope = scope;
    this.login = login;
    this.phone = phone;
    this.password = password;
    this.jar = new CookieJar();
    this.started = false;
    this.captcha = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns CookieJar
   *
   * @return {CookieJar}
   */


  getCookieJar() {
    return this.jar;
  }
  /**
   * Sets the CookieJar
   *
   * @param {CookieJar} jar
   *
   * @return {this}
   */


  setCookieJar(jar) {
    this.jar = jar;
    return this;
  }
  /**
   * Returns cookie
   *
   * @return {Promise<Object>}
   */


  async getCookie() {
    const {
      jar
    } = this;
    const getCookieString = promisify$1(jar.getCookieString).bind(jar);
    const [login, main] = await Promise.all([getCookieString('https://login.vk.com'), getCookieString('https://vk.com')]);
    return {
      'login.vk.com': login,
      'vk.com': main
    };
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, _objectSpread({}, options, {
      agent,
      compress: false,
      headers: _objectSpread({}, headers, {
        'User-Agent': DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run() {
    if (this.started) {
      throw new AuthError({
        message: 'Authorization already started!',
        code: AUTHORIZATION_FAILED$2
      });
    }

    this.started = true;
    this.fetchCookie = fetchCookieFollowRedirectsDecorator(this.jar);
    debug$4('get permissions page');
    let response = await this.getPermissionsPage();
    const isProcessed = true;

    while (isProcessed) {
      const {
        url
      } = response;

      if (url.includes(CALLBACK_BLANK)) {
        return {
          response
        };
      }

      if (url.includes(ACTION_BLOCKED)) {
        debug$4('page blocked');
        throw new AuthError({
          message: 'Page blocked',
          code: PAGE_BLOCKED$1
        });
      }

      const $ = cheerioLoad$2((await response.text()));

      if (url.includes(ACTION_AUTH_CODE$1)) {
        response = await this.processTwoFactorForm(response, $);
        continue;
      }

      if (url.includes(ACTION_SECURITY_CODE$2)) {
        response = await this.processSecurityForm(response, $);
        continue;
      }

      const $error = $('.box_error');
      const $service = $('.service_msg_warning');
      const isError = $error.length !== 0;

      if (this.captcha === null && (isError || $service.length !== 0)) {
        const errorText = isError ? $error.text() : $service.text();
        throw new AuthError({
          message: `Auth form error: ${errorText}`,
          code: AUTHORIZATION_FAILED$2
        });
      }

      if (this.captcha !== null) {
        this.captcha.reject(new AuthError({
          message: 'Incorrect captcha code',
          code: FAILED_PASSED_CAPTCHA$2
        }));
        this.captcha = null;
        this.captchaAttempts += 1;
      }

      if (this.captchaAttempts > CAPTCHA_ATTEMPTS$2) {
        throw new AuthError({
          message: 'Maximum attempts passage captcha',
          code: FAILED_PASSED_CAPTCHA$2
        });
      }

      if ($('input[name="pass"]').length !== 0) {
        debug$4('authorization form');
        response = await this.processAuthForm(response, $);
        continue;
      }

      if (url.includes('act=')) {
        throw new AuthError({
          message: 'Unsupported authorization event',
          code: AUTHORIZATION_FAILED$2
        });
      }

      debug$4('auth with login & pass complete');

      if ($('form').length !== 0) {
        const {
          action
        } = parseFormField($);
        debug$4('url grant access', action);
        response = await this.fetch(action, {
          method: 'POST'
        });
      } else {
        const script = $('script[type="text/javascript"][language="javascript"]').text();
        const locations = script.match(/location\.href\s+=\s+"([^"]+)"/i);

        if (locations === null) {
          throw new AuthError({
            message: 'Could not log in',
            code: AUTHORIZATION_FAILED$2
          });
        }

        const location = locations[1].replace('&cancel=1', '');
        debug$4('url grant access', location);
        response = await this.fetch(location, {
          method: 'POST'
        });
      }
    }
  }
  /**
   * Process form auth
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processAuthForm(response, $) {
    debug$4('process login handle');
    const {
      login,
      password,
      phone
    } = this;
    const {
      action,
      fields
    } = parseFormField($);
    fields.email = login || phone;
    fields.pass = password;

    if ('captcha_sid' in fields) {
      if (this.vk.captchaHandler === null) {
        throw new AuthError({
          message: 'Missing captcha handler',
          code: MISSING_CAPTCHA_HANDLER$2
        });
      }

      const src = $('.oauth_captcha').attr('src') || $('#captcha').attr('src');
      const payload = {
        type: captchaTypes.IMPLICIT_FLOW_AUTH,
        sid: fields.captcha_sid,
        src
      };
      await new Promise((resolveCaptcha, rejectCaptcha) => {
        this.vk.captchaHandler(payload, key => new Promise((resolve, reject) => {
          if (key instanceof Error) {
            rejectCaptcha(key);
            reject(key);
            return;
          }

          fields.captcha_key = key;
          this.captcha = {
            resolve,
            reject
          };
          resolveCaptcha();
        }));
      });
    }

    const url = new URL$4(action);
    url.searchParams.set('utf8', 1);
    return await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams$3(fields)
    });
  }
  /**
   * Process two-factor form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processTwoFactorForm(response, $) {
    debug$4('process two-factor handle');

    if (this.vk.twoFactorHandler === null) {
      throw new AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER$2
      });
    }

    let isProcessed = true;

    while (this.twoFactorAttempts < TWO_FACTOR_ATTEMPTS$2 && isProcessed) {
      // eslint-disable-next-line no-loop-func
      await new Promise((resolve, reject) => {
        this.vk.twoFactorHandler({}, async code => {
          const {
            action,
            fields
          } = parseFormField($);
          fields.code = code;

          try {
            const url = getFullURL(action, response);
            response = await this.fetch(url, {
              method: 'POST',
              body: new URLSearchParams$3(fields)
            });
          } catch (error) {
            reject(error);
            throw error;
          }

          if (response.url.includes(ACTION_AUTH_CODE$1)) {
            resolve();
            throw new AuthError({
              message: 'Incorrect two-factor code',
              code: FAILED_PASSED_TWO_FACTOR$2
            });
          }

          isProcessed = false;
          resolve();
        });
      });
      this.twoFactorAttempts += 1;
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS$2 && isProcessed) {
      throw new AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR$2
      });
    }

    return response;
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug$4('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER$2
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = parseFormField($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = getFullURL(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams$3(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE$2)) {
      throw new AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER$2
      });
    }

    return response;
  }

}

const {
  URL: URL$5,
  URLSearchParams: URLSearchParams$4
} = nodeUrl;
const debug$5 = createDebug('vk-io:auth:implicit-flow-user');
const {
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$3
} = authErrors;
class ImplicitFlowUser extends ImplicitFlow {
  /**
   * Returns permission page
   *
   * @return {Response}
   */
  getPermissionsPage() {
    const {
      app
    } = this;
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = getAllUsersPermissions();
    } else if (typeof scope !== 'number') {
      scope = getUsersPermissionsByName(scope);
    }

    debug$5('auth scope %s', scope);
    const params = new URLSearchParams$4({
      redirect_uri: CALLBACK_BLANK,
      response_type: 'token',
      display: 'page',
      v: API_VERSION,
      client_id: app,
      scope
    });
    const url = new URL$5(`https://oauth.vk.com/authorize?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Starts authorization
   *
   * @return {Promise<Object>}
   */


  async run() {
    const {
      response
    } = await super.run();
    let {
      hash
    } = new URL$5(response.url);

    if (hash.startsWith('#')) {
      hash = hash.substring(1);
    }

    const params = new URLSearchParams$4(hash);

    if (params.has('error')) {
      throw new AuthError({
        message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
        code: AUTHORIZATION_FAILED$3
      });
    }

    const user = params.get('user_id');
    const expires = params.get('expires_in');
    return {
      email: params.get('email'),
      user: user !== null ? Number(user) : null,
      token: params.get('access_token'),
      expires: expires !== null ? Number(expires) : null
    };
  }

}

const {
  URL: URL$6,
  URLSearchParams: URLSearchParams$5
} = nodeUrl;
const debug$6 = createDebug('vk-io:auth:implicit-flow-user');
const {
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$4
} = authErrors;
class ImplicitFlowGroups extends ImplicitFlow {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, options) {
    super(vk, options);
    let {
      groups = null
    } = options;

    if (groups === null) {
      throw Error('Groups list must have');
    }

    if (!Array.isArray(groups)) {
      groups = [groups];
    }

    this.groups = groups.map(group => {
      if (typeof group !== 'number') {
        group = Number(group);
      }

      if (group < 0) {
        group = -group;
      }

      return group;
    });
  }
  /**
   * Returns permission page
   *
   * @param {Array} groups
   *
   * @return {Response}
   */


  getPermissionsPage() {
    const {
      app
    } = this;
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = getAllGroupsPermissions();
    } else if (typeof scope !== 'number') {
      scope = getGroupsPermissionsByName(scope);
    }

    debug$6('auth scope %s', scope);
    const params = new URLSearchParams$5({
      group_ids: this.groups.join(','),
      redirect_uri: CALLBACK_BLANK,
      response_type: 'token',
      display: 'page',
      v: API_VERSION,
      client_id: app,
      scope
    });
    const url = new URL$6(`https://oauth.vk.com/authorize?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Starts authorization
   *
   * @return {Promise<Array>}
   */


  async run() {
    const {
      response
    } = await super.run();
    let {
      hash
    } = new URL$6(response.url);

    if (hash.startsWith('#')) {
      hash = hash.substring(1);
    }

    const params = new URLSearchParams$5(hash);

    if (params.has('error')) {
      throw new AuthError({
        message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
        code: AUTHORIZATION_FAILED$4
      });
    }

    let expires = params.get('expires_in');

    if (expires !== null) {
      expires = Number(expires);
    }

    const tokens = [];

    for (const [name, value] of params) {
      if (!name.startsWith('access_token_')) {
        continue;
      }
      /* Example group access_token_XXXXX */


      const [,, group] = name.split('_');
      tokens.push({
        group: Number(group),
        token: value,
        expires
      });
    }

    return tokens;
  }

}

const {
  inspect: inspect$2
} = nodeUtil;
class Auth {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Auth';
  }
  /**
   * Standalone authorization with login & password
   *
   * @return {ImplicitFlowUser}
   */


  implicitFlowUser(options = {}) {
    return new ImplicitFlowUser(this.vk, options);
  }
  /**
   * Standalone authorization with login & password for group
   *
   * @param {mixed}  groups
   * @param {Object} options
   *
   * @return {ImplicitFlowGroup}
   */


  implicitFlowGroups(groups, options = {}) {
    return new ImplicitFlowGroups(this.vk, _objectSpread({}, options, {
      groups
    }));
  }
  /**
   * Direct authorization with login & login in user application
   *
   * @return {DirectAuth}
   */


  direct() {
    const {
      app,
      key
    } = this.vk.options;
    return new DirectAuth(this.vk, {
      app,
      key
    });
  }
  /**
   * Direct authorization with login & login in android application
   *
   * @return {DirectAuth}
   */


  androidApp() {
    return new DirectAuth(this.vk, {
      app: 2274003,
      key: 'hHbZxrka2uZ6jB1inYsH'
    });
  }
  /**
   * Direct authorization with login & login in windows application
   *
   * @return {DirectAuth}
   */


  windowsApp() {
    return new DirectAuth(this.vk, {
      app: 3697615,
      key: 'AlVXZFMUqyrnABp8ncuU'
    });
  }
  /**
   * Direct authorization with login & login in windows phone application
   *
   * @return {DirectAuth}
   */


  windowsPhoneApp() {
    return new DirectAuth(this.vk, {
      app: 3502557,
      key: 'PEObAuQi6KloPM4T30DV'
    });
  }
  /**
   * Direct authorization with login & login in iphone application
   *
   * @return {DirectAuth}
   */


  iphoneApp() {
    return new DirectAuth(this.vk, {
      app: 3140623,
      key: 'VeWdmVclDCtn6ihuP1nt'
    });
  }
  /**
   * Direct authorization with login & login in ipad application
   *
   * @return {DirectAuth}
   */


  ipadApp() {
    return new DirectAuth(this.vk, {
      app: 3682744,
      key: 'mY6CDUswIVdJLCD3j15n'
    });
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$2.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} {}`;
  }

}

const {
  Stream
} = nodeStream;
/**
 * Check object is stream
 *
 * @param {Object} source
 *
 * @return {boolean}
 */

const isStream = source => typeof source === 'object' && source instanceof Stream;
/**
 * Copies object params to new object
 *
 * @param {Object} params
 * @param {Array}  properties
 *
 * @return {Object}
 */

const copyParams = (params, properties) => {
  const copies = {};

  for (const property of properties) {
    if (property in params) {
      copies[property] = params[property];
    }
  }

  return copies;
};

const {
  PassThrough
} = nodeStream;
const {
  SandwichStream
} = sandwichStream;
const CRNL = '\r\n';
class MultipartStream extends SandwichStream {
  /**
   * Constructor
   *
   * @param {string} boundary
   */
  constructor(boundary) {
    super({
      head: `--${boundary}${CRNL}`,
      tail: `${CRNL}--${boundary}--`,
      separator: `${CRNL}--${boundary}${CRNL}`
    });
    this.boundary = boundary;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'MultipartStream';
  }
  /**
   * Returns boundary
   *
   * @return {string}
   */


  getBoundary() {
    return this.boundary;
  }
  /**
   * Adds part
   *
   * @param {Object} part
   */


  addPart(part = {}) {
    const partStream = new PassThrough();

    if ('headers' in part) {
      for (const [key, header] of Object.entries(part.headers)) {
        partStream.write(`${key}: ${header}${CRNL}`);
      }
    }

    partStream.write(CRNL);

    if (isStream(part.body)) {
      part.body.pipe(partStream);
    } else {
      partStream.end(part.body);
    }

    this.add(partStream);
  }
  /**
   * Adds form data
   *
   * @param {string} field
   * @param {mixed}  body
   * @param {Object} options
   */


  append(field, body, {
    filename = null,
    headers = {}
  }) {
    let header = `form-data; name="${field}"`;

    if (filename !== null) {
      header += `; filename="${filename}"`;
    }

    return this.addPart({
      headers: _objectSpread({}, headers, {
        'content-disposition': header
      }),
      body
    });
  }

}

const {
  inspect: inspect$3
} = nodeUtil;
class Attachment {
  /**
   * Constructor
   *
   * @param {string} type
   * @param {number} owner
   * @param {number} id
   * @param {string} accessKey
   */
  constructor(type, owner, id, accessKey = null) {
    this.type = type;
    this.owner = Number(owner);
    this.id = Number(id);
    this.accessKey = accessKey;
    this.filled = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Parse attachment with string
   *
   * @param {string} attachment
   *
   * @return {Attachment}
   */


  static fromString(attachment) {
    if (!parseAttachment.test(attachment)) {
      throw new Error('Incorrect attachment');
    }

    const [, type, owner, id, accessKey] = attachment.match(parseAttachment);
    return new Attachment(type, owner, id, accessKey);
  }
  /**
   * Returns whether the attachment is filled
   *
   * @return {boolean}
   */


  isFilled() {
    return this.filled;
  }
  /**
   * Returns type attachment
   *
   * @return {string}
   */


  getType() {
    return this.type;
  }
  /**
   * Returns the identifier owner
   *
   * @return {number}
   */


  getOwnerId() {
    return this.owner;
  }
  /**
   * Returns the identifier attachment
   *
   * @return {number}
   */


  getId() {
    return this.id;
  }
  /**
   * Checks that the attachment is equivalent with object
   *
   * @param {Attachment} attachment
   *
   * @return {boolean}
   */


  equals(attachment) {
    if (!attachment) {
      return false;
    }

    if (this.getType() !== attachment.getType()) {
      return false;
    }

    if (this.getOwnerId() !== attachment.getOwnerId()) {
      return false;
    }

    if (this.getId() !== attachment.getId()) {
      return false;
    }

    return true;
  }
  /**
   * Checks that the attachment is equivalent with string
   *
   * @param {string} attachment
   *
   * @return {boolean}
   */


  equalString(attachment) {
    return this.equals(Attachment.fromString(attachment));
  }
  /**
   * Returns a string to attach a VK
   *
   * @return {string}
   */


  toString() {
    const accessKey = this.accessKey !== null ? `_${this.accessKey}` : '';
    return `${this.type}${this.owner}_${this.id}${accessKey}`;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$3.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const payload = this.filled ? ` ${inspect$3(this.payload, options)} ` : '';
    return `${options.stylize(name, 'special')} { ${options.stylize(this, 'string')} ${payload}}`;
  }

}

const {
  inspect: inspect$4
} = nodeUtil;
class ExternalAttachment {
  /**
   * Constructor
   *
   * @param {string} type
   * @param {Object} payload
   */
  constructor(type, payload) {
    this.type = type;
    this.payload = payload;
    this.filled = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns whether the attachment is filled
   *
   * @return {boolean}
   */


  isFilled() {
    return this.filled;
  }
  /**
   * Returns type attachment
   *
   * @return {string}
   */


  getType() {
    return this.type;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$4.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const payload = this.filled ? ` ${inspect$4(this.payload, options)} ` : '';
    return `${options.stylize(name, 'special')} { ${options.stylize(this, 'string')} ${payload}}`;
  }

}

class GiftAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('gift', payload);
    this.vk = vk;
  }
  /**
   * Returns the identifier gift
   *
   * @return {number}
   */


  getId() {
    return this.payload.id;
  }

}

/**
 * Transform raw attachments to wrapper
 *
 * @param {Array} attachments
 * @param {VK}    vk
 *
 * @return {Array}
 */
// eslint-disable-next-line import/prefer-default-export

const transformAttachments = (attachments = [], vk) => attachments.map(item => {
  const {
    type
  } = item;
  const attachment = item[type];

  switch (type) {
    case 'gift':
      return new GiftAttachment(attachment, vk);

    case 'wall':
      return new WallAttachment(attachment, vk);

    case 'link':
      return new LinkAttachment(attachment, vk);

    case 'photo':
      return new PhotoAttachment(attachment, vk);

    case 'audio':
      return new AudioAttachment(attachment, vk);

    case 'video':
      return new VideoAttachment(attachment, vk);

    case 'market':
      return new MarketAttachment(attachment, vk);

    case 'sticker':
      return new StickerAttachment(attachment, vk);

    case 'doc':
      return new DocumentAttachment(attachment, vk);

    case 'wall_reply':
      return new WallReplyAttachment(attachment, vk);

    case 'market_album':
      return new MarketAlbumAttachment(attachment, vk);

    default:
      return false;
  }
}).filter(Boolean);

class WallAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('wall', payload.owner_id, payload.id, payload.access_key);
    this.payload = payload;
    this.attachments = transformAttachments(payload.attachments);
    this.filled = 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const [post] = await this.vk.api.wall.getById({
      posts: `${this.owner}_${this.id}`,
      extended: 0
    });
    this.payload = post;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }
  /**
   * Checks has comments
   *
   * @return {?boolean}
   */


  hasComments() {
    if (!this.filled) {
      return null;
    }

    return this.payload.comments.count > 0;
  }
  /**
   * Checks has ads in post
   *
   * @return {?boolean}
   */


  hasAds() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.marked_as_ads);
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Checks has this user reposted
   *
   * @return {?boolean}
   */


  hasUserReposted() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.reposts.user_reposted);
  }
  /**
   * Checks has this user likes
   *
   * @return {?boolean}
   */


  hasUserLike() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.user_likes);
  }
  /**
   * Checks can the current user comment on the entry
   *
   * @return {?boolean}
   */


  isCanUserCommented() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.comments.can_post);
  }
  /**
   * Checks if a community can comment on a post
   *
   * @return {?boolean}
   */


  isCanGroupsCommented() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.comments.groups_can_post);
  }
  /**
   * Checks if you can comment on a post
   *
   * @return {?boolean}
   */


  isCanCommented() {
    return this.isCanUserCommented() || this.isCanGroupsCommented();
  }
  /**
   * Checks whether the current user can like the record
   *
   * @return {?boolean}
   */


  isCanLike() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.likes.can_like);
  }
  /**
   * hecks whether the current user can repost the record
   *
   * @return {?boolean}
   */


  isCanReposted() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.likes.can_publish);
  }
  /**
   * Checks is can this user pin post
   *
   * @return {?boolean}
   */


  isCanPin() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.can_pin);
  }
  /**
   * Checks is can this user delete post
   *
   * @return {?boolean}
   */


  isCanDelete() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.can_delete);
  }
  /**
   * Checks is can this user edit post
   *
   * @return {?boolean}
   */


  isCanEdit() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.can_edit);
  }
  /**
   * Checks is can this user edit post
   *
   * @return {?boolean}
   */


  isPinned() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.is_pinned);
  }
  /**
   * Checks is post created only by friends
   *
   * @return {?boolean}
   */


  isFriendsOnly() {
    if (!this.filled) {
      return null;
    }

    return Boolean(this.payload.friends_only);
  }
  /**
   * Returns the timestamp when this post was created
   *
   * @return {number}
   */


  getTimestamp() {
    return this.payload.date || null;
  }
  /**
   * Returns the Date object when this post was created
   *
   * @return {?Date}
   */


  getDate() {
    const {
      date
    } = this.payload;
    return date ? new Date(date) : null;
  }
  /**
   * Returns the identifier author
   *
   * @return {?number}
   */


  getAuthorId() {
    return this.payload.from_id || null;
  }
  /**
   * Returns the post type
   *
   * @return {?string}
   */


  getPostType() {
    return this.payload.post_type || null;
  }
  /**
   * Returns the post text
   *
   * @return {?string}
   */


  getText() {
    return this.payload.text || null;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }
  /**
   * Returns the administrator identifier that posted the entry
   *
   * @return {?number}
   */


  getCreatedUserId() {
    return this.payload.created_by || null;
  }
  /**
   * The identifier of the record owner, in response to which the current
   *
   * @return {?number}
   */


  getReplyOwnerId() {
    return this.payload.reply_owner_id || null;
  }
  /**
   * The identifier of the record in response to which the current one was left.
   *
   * @return {?number}
   */


  getReplyPostId() {
    return this.payload.reply_post_id || null;
  }
  /**
   * Returns author identifier if the entry was published
   * on behalf of the community and signed by the user
   *
   * @return {?number}
   */


  getSignerId() {
    return this.payload.signer_id || null;
  }
  /**
   * Returns the number of record views
   *
   * @return {?number}
   */


  getViewsCount() {
    if (!this.filled) {
      return null;
    }

    return this.payload.views.count;
  }
  /**
   * Returns the geo location
   *
   * @return {?Object}
   */


  getGeo() {
    return this.payload.geo || null;
  }
  /**
   * Returns the likes info
   *
   * @return {?Object}
   */


  getLikes() {
    return this.payload.likes || null;
  }
  /**
   * Returns the likes count
   *
   * @return {?number}
   */


  getLikesCount() {
    if (!this.filled) {
      return null;
    }

    return this.payload.likes.count;
  }
  /**
   * Returns the reposts count
   *
   * @return {?number}
   */


  getRepostsCount() {
    if (!this.filled) {
      return null;
    }

    return this.payload.reposts.count;
  }
  /**
   * Returns the post source
   *
   * @return {?Object}
   */


  getPostSource() {
    return this.payload.post_source || null;
  }

}

class LinkAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('link', payload);
    this.vk = vk;
  }
  /**
   * Returns the URL of the link
   *
   * @return {string}
   */


  getUrl() {
    return this.payload.url;
  }
  /**
   * Returns the title
   *
   * @return {string}
   */


  getTitle() {
    return this.payload.title;
  }
  /**
   * Returns the description
   *
   * @return {string}
   */


  getDescription() {
    return this.payload.description;
  }

}

class PhotoAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('photo', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.filled = 'album_id' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const [photo] = await this.vk.api.photos.getById({
      photos: `${this.owner}_${this.id}`,
      extended: 0
    });
    this.payload = photo;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }
  /**
   * Returns the ID of the user who uploaded the image
   *
   * @return {?number}
   */


  getUserId() {
    return this.payload.user_id || null;
  }
  /**
   * Returns the ID of the album
   *
   * @return {?number}
   */


  getAlbumId() {
    return this.payload.album_id || null;
  }
  /**
   * Returns the photo text
   *
   * @return {?string}
   */


  getText() {
    return this.payload.text || null;
  }
  /**
   * Returns the timestamp when this photo was created
   *
   * @return {number}
   */


  getTimestamp() {
    return this.payload.date || null;
  }
  /**
   * Returns the Date object when this photo was created
   *
   * @return {?Date}
   */


  getDate() {
    const {
      date
    } = this.payload;
    return date ? new Date(date) : null;
  }
  /**
   * Returns the photo height
   *
   * @return {?number}
   */


  getHeight() {
    return this.payload.height || null;
  }
  /**
   * Returns the photo width
   *
   * @return {?number}
   */


  getWidth() {
    return this.payload.width || null;
  }
  /**
   * Returns the URL of a small photo
   * (130 or 75)
   *
   * @return {?string}
   */


  getSmallPhoto() {
    if (!this.filled) {
      return null;
    }

    return getSmallPhoto(this.payload);
  }
  /**
   * Returns the URL of a medium photo
   * (807 or 604 or less)
   *
   * @return {?string}
   */


  getMediumPhoto() {
    if (!this.filled) {
      return null;
    }

    return getMediumPhoto(this.payload);
  }
  /**
   * Returns the URL of a large photo
   * (2560 or 1280 or less)
   *
   * @return {?string}
   */


  getLargePhoto() {
    if (!this.filled) {
      return null;
    }

    return getLargePhoto(this.payload);
  }

}

class AudioAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('audio', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.filled = 'duration' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const [audio] = await this.vk.api.audio.getById({
      audios: `${this.owner}_${this.id}`
    });
    this.payload = audio;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }
  /**
   * Checks whether audio is in high quality
   *
   * @return {?boolean}
   */


  isHq() {
    const {
      is_hq: isHq
    } = this.payload;

    if (!isHq) {
      return null;
    }

    return isHq === 1;
  }
  /**
   * Returns the artist
   *
   * @return {?string}
   */


  getArtist() {
    return this.payload.artist || null;
  }
  /**
   * Returns the title
   *
   * @return {?string}
   */


  getTitle() {
    return this.payload.title || null;
  }
  /**
   * Returns the duration
   *
   * @return {?number}
   */


  getDuration() {
    return this.payload.duration || null;
  }
  /**
   * Returns the timestamp when this audio was created
   *
   * @return {?number}
   */


  getTimestamp() {
    return this.payload.date || null;
  }
  /**
   * Returns the Date object when this audio was created
   *
   * @return {?Date}
   */


  getDate() {
    const {
      date
    } = this.payload;
    return date ? new Date(date) : null;
  }
  /**
   * Returns the URL of the audio
   *
   * @return {?string}
   */


  getUrl() {
    return this.payload.url || null;
  }
  /**
   * Returns the ID of the lyric
   *
   * @return {?number}
   */


  getLyricsId() {
    return this.payload.lyrics_id || null;
  }
  /**
   * Returns the ID of the album
   *
   * @return {?number}
   */


  getAlbumId() {
    return this.payload.album_id || null;
  }
  /**
   * Returns the ID of the genre
   *
   * @return {?number}
   */


  getGenreId() {
    return this.payload.album_id || null;
  }

}

class VideoAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('video', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload; // this.filled = 'duration' in payload && 'date' in payload;

    this.filled = 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const {
      items
    } = await this.vk.api.video.get({
      videos: `${this.owner}_${this.id}`,
      extended: 0
    });
    const [video] = items;
    this.payload = video;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }
  /**
   * Checks whether the video is repeatable
   *
   * @return {?boolean}
   */


  isRepeat() {
    return this.checkBooleanInProperty('repeat');
  }
  /**
   * Checks that the user can add a video to himself
   *
   * @return {?boolean}
   */


  isCanAdd() {
    return this.checkBooleanInProperty('can_add');
  }
  /**
   * Checks if the user can edit the video
   *
   * @return {?boolean}
   */


  isCanEdit() {
    return this.checkBooleanInProperty('can_edit');
  }
  /**
   * Checks whether the video is being processed
   *
   * @return {?boolean}
   */


  isProcessing() {
    return this.checkBooleanInProperty('processing');
  }
  /**
   * Checks whether the video is a broadcast
   *
   * @return {?boolean}
   */


  isBroadcast() {
    return this.checkBooleanInProperty('live');
  }
  /**
   * Checks whether the video is a broadcast
   *
   * @return {?boolean}
   */


  isUpcoming() {
    return this.checkBooleanInProperty('upcoming');
  }
  /**
   * Returns the title
   *
   * @return {?string}
   */


  getTitle() {
    return this.payload.title || null;
  }
  /**
   * Returns the description
   *
   * @return {?string}
   */


  getDescription() {
    return this.payload.description || null;
  }
  /**
   * Returns the duration
   *
   * @return {?number}
   */


  getDuration() {
    return this.payload.duration || null;
  }
  /**
   * Returns the timestamp when this video was created
   *
   * @return {number}
   */


  getTimestamp() {
    return this.payload.date || null;
  }
  /**
   * Returns the Date object when this video was created
   *
   * @return {?Date}
   */


  getDate() {
    const {
      date
    } = this.payload;
    return date ? new Date(date) : null;
  }
  /**
   * Returns the timestamp when this video was added
   *
   * @return {number}
   */


  getAddingTimestamp() {
    return this.payload.adding_date || null;
  }
  /**
   * Returns the Date object when this video was added
   *
   * @return {?Date}
   */


  getAddingDate() {
    const {
      adding_date: date
    } = this.payload;
    return date ? new Date(date) : null;
  }
  /**
   * Returns the count views
   *
   * @return {?number}
   */


  getViewsCount() {
    return this.payload.views || null;
  }
  /**
   * Returns the count comments
   *
   * @return {?number}
   */


  getCommentsCount() {
    return this.payload.comments || null;
  }
  /**
   * Returns the URL of the page with the player
   *
   * @return {?string}
   */


  getPlayer() {
    return this.payload.player || null;
  }
  /**
   * Returns the name of the platform (for video recordings added from external sites)
   *
   * @return {?string}
   */


  getPlatformName() {
    return this.payload.platform || null;
  }
  /**
   * Checks for a boolean value in the property
   *
   * @param {string} name
   *
   * @return {?boolean}
   */


  checkBooleanInProperty(name) {
    const property = this.payload[name];

    if (typeof property !== 'number') {
      return null;
    }

    return property === 1;
  }

}

class MarketAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('market', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.filled = 'title' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const [market] = await this.vk.api.market.getById({
      item_ids: `${this.owner}_${this.id}`,
      extended: 0
    });
    this.payload = market;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }

}

class StickerAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('sticker', payload);
    this.vk = vk;
  }
  /**
   * Returns the identifier sticker
   *
   * @return {number}
   */


  getId() {
    return this.payload.sticker_id;
  }
  /**
   * Returns the identifier product
   *
   * @return {number}
   */


  getProductId() {
    return this.payload.product_id;
  }

}

/**
 * Types of documents
 *
 * @type {Map}
 */

const documentTypes = new Map([[1, 'text'], [2, 'archive'], [3, 'gif'], [4, 'image'], [5, 'audio'], [6, 'video'], [7, 'book'], [8, 'unknown']]);
class DocumentAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('doc', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.filled = 'ext' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const [document] = await this.vk.api.docs.getById({
      docs: `${this.owner}_${this.id}`
    });
    this.payload = document;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }
  /**
   * Checks if the document is a text
   *
   * @return {?boolean}
   */


  isText() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 1;
  }
  /**
   * Checks if the document is a archive
   *
   * @return {?boolean}
   */


  isArchive() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 2;
  }
  /**
   * Checks if the document is a gif file
   *
   * @return {?boolean}
   */


  isGif() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 3;
  }
  /**
   * Checks if the document is a image
   *
   * @return {?boolean}
   */


  isImage() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 4;
  }
  /**
   * Checks if the document is a graffiti
   *
   * @return {?boolean}
   */


  isGraffiti() {
    if (!this.filled) {
      return null;
    }

    return this.hasPreviewProperty('graffiti');
  }
  /**
   * Checks if the document is a audio
   *
   * @return {?boolean}
   */


  isAudio() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 5;
  }
  /**
   * Checks if the document is a voice
   *
   * @return {?boolean}
   */


  isVoice() {
    if (!this.filled) {
      return null;
    }

    return this.hasPreviewProperty('audio_msg');
  }
  /**
   * Checks if the document is a video
   *
   * @return {?boolean}
   */


  isVideo() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 6;
  }
  /**
   * Checks if the document is a book
   *
   * @return {?boolean}
   */


  isBook() {
    if (!this.filled) {
      return null;
    }

    return this.payload.type === 7;
  }
  /**
   * Returns the document title
   *
   * @return {?string}
   */


  getTitle() {
    return this.payload.title || null;
  }
  /**
   * Returns the timestamp when this document was created
   *
   * @return {number}
   */


  getTimestamp() {
    return this.payload.date || null;
  }
  /**
   * Returns the Date object when this document was created
   *
   * @return {?Date}
   */


  getDate() {
    const {
      date
    } = this.payload;
    return date ? new Date(date) : null;
  }
  /**
   * Returns the type identifier (1~8)
   *
   * @return {?number}
   */


  getTypeId() {
    return this.payload.type || null;
  }
  /**
   * Returns the type name
   *
   * @return {?string}
   */


  getTypeName() {
    if (!this.filled) {
      return null;
    }

    return documentTypes.get(this.payload.type);
  }
  /**
   * Returns the size in bytes
   *
   * @return {?number}
   */


  getSize() {
    return this.payload.size || null;
  }
  /**
   * Returns the extension
   *
   * @return {?string}
   */


  getExtension() {
    return this.payload.ext || null;
  }
  /**
   * Returns the URL of the document
   *
   * @return {?string}
   */


  getUrl() {
    return this.payload.url || null;
  }
  /**
   * Returns the info to preview
   *
   * @return {?Object}
   */


  getPreview() {
    return this.payload.preview || null;
  }
  /**
   * Checks for a property in preview
   *
   * @param {string} name
   *
   * @return {boolean}
   */


  hasPreviewProperty(name) {
    const preview = this.getPreview();

    if (preview === null) {
      return false;
    }

    return name in preview;
  }

}

class WallReplyAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('wall_reply', payload);
    this.vk = vk;
  }

}

class MarketAlbumAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('market_album', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.filled = 'title' in payload && 'updated_time' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.filled) {
      return;
    }

    const [album] = await this.vk.api.market.getAlbumById({
      owner_id: this.owner,
      album_ids: this.id
    });
    this.payload = album;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.filled = true;
  }

}

const {
  createReadStream
} = nodeFs;
const {
  randomBytes
} = nodeCrypto;
const {
  inspect: inspect$5
} = nodeUtil;
const {
  NO_FILES_TO_UPLOAD,
  EXCEEDED_MAX_FILES,
  UNSUPPORTED_SOURCE_TYPE
} = uploadErrors;
const isURL = /^https?:\/\//i;
class Upload {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Upload';
  }
  /**
   * Uploading photos to an album
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment[]>}
   */


  async photoAlbum(params) {
    const photos = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getUploadServer,
      serverParams: ['album_id', 'group_id'],
      saveFiles: this.vk.api.photos.save,
      saveParams: ['album_id', 'group_id', 'latitude', 'longitude', 'caption'],
      maxFiles: 5,
      attachmentType: 'photo'
    });
    return photos.map(photo => new PhotoAttachment(photo, this.vk));
  }
  /**
   * Uploading photos to the wall
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async wallPhoto(params) {
    const [photo] = await this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getWallUploadServer,
      serverParams: ['group_id'],
      saveFiles: this.vk.api.photos.saveWallPhoto,
      saveParams: ['user_id', 'group_id', 'latitude', 'longitude', 'caption'],
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploading the main photo of a user or community
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  ownerPhoto(params) {
    return this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getOwnerPhotoUploadServer,
      serverParams: ['owner_id'],
      saveFiles: this.vk.api.photos.saveOwnerPhoto,
      maxFiles: 1,
      attachmentType: 'photo'
    }); // {
    // 	photo_hash: 'c8d43da5e1281b7aed6bb8f0c4f3ad69',
    // 	photo_src: 'https://pp.userapi.com/c836429/v836429114/673f6/5VJB8GXtK88.jpg',
    // 	photo_src_big: 'https://pp.userapi.com/c836429/v836429114/673f7/7fGvrJ1wOx0.jpg',
    // 	photo_src_small: 'https://pp.userapi.com/c836429/v836429114/673f5/l5d1ASgyuxk.jpg',
    // 	saved: 1,
    // 	post_id: 3331
    // }
  }
  /**
   * Uploading a photo to a private message
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async messagePhoto(params) {
    const [photo] = await this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getMessagesUploadServer,
      serverParams: ['peer_id'],
      saveFiles: this.vk.api.photos.saveMessagesPhoto,
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploading the main photo for a chat
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  chatPhoto(params) {
    return this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getChatUploadServer,
      serverParams: ['chat_id', 'crop_x', 'crop_y', 'crop_width'],
      saveFiles: file => this.vk.api.messages.setChatPhoto({
        file
      }),
      maxFiles: 1,
      attachmentType: 'photo'
    }); // {
    // 	message_id: 3745390,
    // 	chat: {
    // 		id: 152,
    // 		type: 'chat',
    // 		title: '<Titile name>',
    // 		admin_id: 335447860,
    // 		users: [335447860,
    // 			140192020,
    // 			153711615,
    // 			314650825,
    // 			218747758,
    // 			155944103,
    // 			159737827,
    // 			64299368,
    // 			157534541,
    // 			153608064,
    // 			335540121,
    // 			349609849,
    // 			344184938,
    // 			341178526,
    // 			198210835,
    // 			135446999,
    // 			163850606,
    // 			123640861,
    // 			316216798,
    // 			359118107,
    // 			241235369,
    // 			160213445,
    // 			126624591,
    // 			390221395,
    // 			195624402,
    // 			94955334,
    // 			167302501,
    // 			17516523,
    // 			294583792,
    // 			294869767,
    // 			114281676,
    // 			137762280,
    // 			406076540,
    // 			410605840,
    // 			395646590,
    // 			421554042,
    // 			331599090,
    // 			342269712
    // 		],
    // 		photo_50: 'https://pp.userapi.com/c837624/v837624114/5d495/gLgv-JrVmkk.jpg',
    // 		photo_100: 'https://pp.userapi.com/c837624/v837624114/5d494/VNp61I1yuCk.jpg',
    // 		photo_200: 'https://pp.userapi.com/c837624/v837624114/5d492/lAoc_fAai2Q.jpg'
    // 	}
    // }
  }
  /**
   * Uploading a photo for a product
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async marketPhoto(params) {
    const [photo] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getMarketUploadServer,
      serverParams: ['group_id', 'main_photo', 'crop_x', 'crop_y', 'crop_width'],
      saveFiles: this.vk.api.photos.saveMarketPhoto,
      saveParams: ['group_id'],
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploads a photo for the selection of goods
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async marketAlbumPhoto(params) {
    const [photo] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getMarketAlbumUploadServer,
      serverParams: ['group_id'],
      saveFiles: this.vk.api.photos.saveMarketAlbumPhoto,
      saveParams: ['group_id'],
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploads audio
   *
   * @param {Object} params
   *
   * @return {Promise<AudioAttachment>}
   */


  async audio(params) {
    const audio = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.audio.getUploadServer,
      saveFiles: this.vk.api.audio.save,
      saveParams: ['title', 'artist'],
      maxFiles: 1,
      attachmentType: 'audio'
    });
    return new AudioAttachment(audio, this.vk);
  }
  /**
   * Uploads video
   *
   * @param {Object} params
   *
   * @return {Promise<VideoAttachment>}
   */


  async video(params) {
    /* FIXME: 400 Bad Request */
    const save = await this.vk.api.video.save(copyParams(params, ['group_id', 'album_id', 'name', 'description', 'link', 'is_private', 'wallpost', 'privacy_view', 'privacy_comment', 'no_comments', 'repeat']));
    save.id = save.video_id;

    if ('link' in params) {
      const response = await fetch(save.upload_url, {
        agent: this.vk.options.agent
      });
      await response.json();
      return new VideoAttachment(save, this.vk);
    }

    if (!Array.isArray(params.source)) {
      params.source = [params.source];
    }

    const formData = await this.buildPayload({
      maxFiles: 1,
      field: 'video_file',
      attachmentType: 'video',
      sources: params.source
    });
    const video = await this.upload(save.upload_url, formData);
    return new VideoAttachment(_objectSpread({}, save, video), this.vk);
  }
  /**
   * Uploads document
   *
   * @param {Object} params
   * @param {Object} options
   *
   * @return {Promise<DocumentAttachment>}
   */


  async document(params, {
    attachmentType = null
  } = {}) {
    const [document] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.docs.getUploadServer,
      serverParams: ['type', 'group_id'],
      saveFiles: this.vk.api.docs.save,
      saveParams: ['title', 'tags'],
      maxFiles: 1,
      attachmentType: attachmentType || 'doc'
    });
    return new DocumentAttachment(document, this.vk);
  }
  /**
   * Uploads wall document
   *
   * @param {Object} params
   * @param {Object} options
   *
   * @return {Promise<DocumentAttachment>}
   */


  async wallDocument(params, {
    attachmentType = null
  } = {}) {
    const [document] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.docs.getWallUploadServer,
      serverParams: ['type', 'group_id'],
      saveFiles: this.vk.api.docs.save,
      saveParams: ['title', 'tags'],
      maxFiles: 1,
      attachmentType: attachmentType || 'doc'
    });
    return new DocumentAttachment(document, this.vk);
  }
  /**
   * Uploads message document
   *
   * @param {Object} params
   * @param {Object} options
   *
   * @return {Promise<DocumentAttachment>}
   */


  async messageDocument(params, {
    attachmentType = null
  } = {}) {
    const [document] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.docs.getMessagesUploadServer,
      serverParams: ['type', 'peer_id'],
      saveFiles: this.vk.api.docs.save,
      saveParams: ['title', 'tags'],
      maxFiles: 1,
      attachmentType: attachmentType || 'doc'
    });
    return new DocumentAttachment(document, this.vk);
  }
  /**
   * Uploads audio message
   *
   * @param {Object} params
   *
   * @return {Promise<DocumentAttachment>}
   */


  voice(params) {
    params.type = 'audio_message';
    return this.messageDocument(params, {
      attachmentType: 'voice'
    }); // [{
    // 	id: 450654090,
    // 	owner_id: 195624402,
    // 	title: 'file0.dat',
    // 	size: 6893689,
    // 	ext: 'ogg',
    // 	url: 'https://vk.com/doc195624402_450654090?hash=4885f0597af540ea3c&dl=GE4TKNRSGQ2DAMQ:1505453671:d23a533d7c485e7426&api=1&no_preview=1',
    // 	date: 1505453671,
    // 	type: 5,
    // 	preview: {
    // 		audio_msg: {
    // 			duration: 243,
    // 			waveform: [5,
    // 				6,
    // 				5,
    // 				5,
    // 				4,
    // 				3,
    // 				4,
    // 				2,
    // 				4,
    // 				3,
    // 				4,
    // 				4,
    // 				3,
    // 				2,
    // 				1,
    // 				1,
    // 				2,
    // 				3,
    // 				4,
    // 				4,
    // 				6,
    // 				8,
    // 				13,
    // 				13,
    // 				11,
    // 				6,
    // 				5,
    // 				4,
    // 				3,
    // 				3,
    // 				1,
    // 				2,
    // 				1,
    // 				2,
    // 				1,
    // 				4,
    // 				8,
    // 				10,
    // 				12,
    // 				10,
    // 				13,
    // 				12,
    // 				14,
    // 				16,
    // 				16,
    // 				17,
    // 				11,
    // 				9,
    // 				8,
    // 				9,
    // 				10,
    // 				10,
    // 				7,
    // 				1,
    // 				3,
    // 				1,
    // 				2,
    // 				5,
    // 				8,
    // 				10,
    // 				10,
    // 				11,
    // 				13,
    // 				14,
    // 				18,
    // 				19,
    // 				20,
    // 				22,
    // 				20,
    // 				22,
    // 				24,
    // 				25,
    // 				27,
    // 				25,
    // 				21,
    // 				20,
    // 				18,
    // 				15,
    // 				12,
    // 				6,
    // 				3,
    // 				4,
    // 				6,
    // 				10,
    // 				13,
    // 				10,
    // 				9,
    // 				8,
    // 				5,
    // 				3,
    // 				2,
    // 				3,
    // 				8,
    // 				11,
    // 				10,
    // 				2,
    // 				2,
    // 				9,
    // 				12,
    // 				19,
    // 				...23 more items
    // 			],
    // 			link_ogg: 'https://cs540101.userapi.com/c807320/u195624402/audio/440482857b.ogg',
    // 			link_mp3: 'https://cs540101.userapi.com/c807320/u195624402/audio/440482857b.mp3'
    // 		}
    // 	}
    // }]
  }
  /**
   * Uploads graffiti
   *
   * @param {Object} params
   *
   * @return {Promise<DocumentAttachment>}
   */


  graffiti(params) {
    params.type = 'graffiti';
    return this.document(params, {
      attachmentType: 'graffiti'
    });
  }
  /**
   * Uploads community cover
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  groupCover(params) {
    return this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getOwnerCoverPhotoUploadServer,
      serverParams: ['group_id', 'crop_x', 'crop_y', 'crop_x2', 'crop_y2'],
      saveFiles: this.vk.api.photos.saveOwnerCoverPhoto,
      maxFiles: 1,
      attachmentType: 'photo'
    }); // {
    // 	images: [
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46404/r-1Nhr-Dktc.jpg',
    // 			width: 200,
    // 			height: 50
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46403/oDB9tAgtUrQ.jpg',
    // 			width: 400,
    // 			height: 101
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46400/gLwCTmDEPXY.jpg',
    // 			width: 795,
    // 			height: 200
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46402/w2ucyq8zwF8.jpg',
    // 			width: 1080,
    // 			height: 272
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46401/YTmN89yMaU0.jpg',
    // 			width: 1590,
    // 			height: 400
    // 		}
    // 	]
    // }
  }
  /**
   * Uploads photo stories
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  storiesPhoto(params) {
    return this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.stories.getPhotoUploadServer,
      serverParams: ['add_to_news', 'user_ids', 'reply_to_story', 'link_text', 'link_url', 'group_id'],
      saveFiles: save => save,
      maxFiles: 1,
      attachmentType: 'photo'
    });
  }
  /**
   * Uploads video stories
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  storiesVideo(params) {
    return this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.stories.getVideoUploadServer,
      serverParams: ['add_to_news', 'user_ids', 'reply_to_story', 'link_text', 'link_url', 'group_id'],
      saveFiles: save => save,
      maxFiles: 1,
      attachmentType: 'video'
    });
  }
  /**
   * Behavior for the upload method
   *
   * @param {Object} conduct
   * @property [field]          Field name
   * @property [params]         Upload params
   *
   * @property [getServer]      Get server functions
   * @property [serverParams]   Copies server params
   *
   * @property [saveFiles]      Save files functions
   * @property [saveParams]     Copies save params
   *
   * @property [maxFiles]       Max uploaded files for one request
   * @property [attachmentType] Attachment type
   *
   * @return {Promise<Object>}
   */


  async conduct({
    field,
    params,
    getServer,
    serverParams = [],
    saveFiles,
    saveParams = [],
    maxFiles = 1,
    attachmentType
  }) {
    if (!Array.isArray(params.source)) {
      params.source = [params.source];
    }

    params.source = params.source.filter(Boolean);

    if (params.source.length === 0) {
      throw new UploadError({
        message: 'No files to upload',
        code: NO_FILES_TO_UPLOAD
      });
    }

    if (params.source.length > maxFiles) {
      throw new UploadError({
        message: 'The number of files uploaded has exceeded',
        code: EXCEEDED_MAX_FILES
      });
    }

    if ('uploadUrl' in params) {
      getServer = () => ({
        upload_url: params.uploadUrl
      });
    }

    const [{
      upload_url: url
    }, formData] = await Promise.all([getServer(copyParams(params, serverParams)), this.buildPayload({
      field,
      maxFiles,
      attachmentType,
      sources: params.source
    })]);
    const uploaded = await this.upload(url, formData, params);

    if (typeof uploaded !== 'object') {
      return await saveFiles(uploaded);
    }

    return await saveFiles(_objectSpread({}, copyParams(params, saveParams), uploaded));
  }
  /**
   * Building form data
   *
   * @param {Object} payload
   *
   * @return {Promise}
   */


  async buildPayload({
    field,
    sources,
    maxFiles,
    attachmentType
  }) {
    const boundary = randomBytes(32).toString('hex');
    const formData = new MultipartStream(boundary);
    const isMultipart = maxFiles > 1;
    const tasks = sources.map(source => {
      if (typeof source === 'object' && 'value' in source) {
        return source;
      }

      return {
        value: source
      };
    }).map(async ({
      value,
      filename,
      contentType = null
    }, i) => {
      if (typeof value === 'string') {
        if (isURL.test(value)) {
          const response = await fetch(value);
          value = response.body;
        } else {
          value = createReadStream(value);
        }
      }

      if (!filename) {
        filename = `file${i}.${defaultExtensions[attachmentType] || 'dat'}`;
      }

      if (isStream(value) || Buffer.isBuffer(value)) {
        const name = isMultipart ? field + (i + 1) : field;
        const headers = {};

        if (contentType !== null) {
          headers['Content-Type'] = contentType;
        } else if (attachmentType in defaultContentTypes) {
          headers['Content-Type'] = defaultContentTypes[attachmentType];
        }

        return formData.append(name, value, {
          filename,
          headers
        });
      }

      throw new UploadError({
        message: 'Unsupported source type',
        code: UNSUPPORTED_SOURCE_TYPE
      });
    });
    await Promise.all(tasks);
    return formData;
  }
  /**
   * Upload form data
   *
   * @param {URL|string}      url
   * @param {MultipartStream} formData
   * @param {Object}          options
   *
   * @return {Promise<Object>}
   */


  async upload(url, formData, {
    timeout
  } = {}) {
    const {
      agent,
      uploadTimeout
    } = this.vk.options;
    let response = await fetch(url, {
      agent,
      compress: false,
      method: 'POST',
      timeout: timeout || uploadTimeout,
      headers: {
        'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`
      },
      body: formData
    });

    if (response.status !== 200) {
      throw new Error(response.statusText);
    }

    response = await response.json();

    if ('response' in response) {
      return response.response;
    }

    return response;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$5.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} {}`;
  }

}

const unespaceOffset = /"offset":"(\w+)"/g;
var getExecuteCode = (({
  method,
  params,
  parallelCount
}) => {
  const methodCode = getExecuteMethod(method, _objectSpread({}, params, {
    offset: 'offset'
  }));
  const code = `
		var total = parseInt(Args.total);
		var offset = parseInt(Args.offset);
		var received = parseInt(Args.received);

		var proceed = total == 0 || received < total;

		var i = 0, items = [], result, length;

		while (i < ${parallelCount} && proceed) {
			result = ${methodCode};
			length = result.items.length;

			if (total == 0 || total > result.count) {
				total = result.count;
			}

			items = items + result.items;

			offset = offset + length;
			received = received + length;

			proceed = received < total;
			i = i + 1;
		}

		return {
			total: total,
			items: items.splice(0, total)
		};
	`;
  return code.replace(unespaceOffset, '"offset":$1');
});

const {
  inspect: inspect$6
} = nodeUtil;
const {
  Readable
} = nodeStream;
const debug$7 = createDebug('vk-io:collect:stream');
const {
  APP_TOKEN_NOT_VALID,
  RESPONSE_SIZE_TOO_BIG
} = apiErrors;
const {
  EXECUTE_ERROR
} = collectErrors;
class CollectStream extends Readable {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk, {
    options,
    method,
    limit,
    max = null
  }) {
    super({
      objectMode: true
    });
    this.vk = vk;

    const {
      parallelCount = 25,
      count = null,
      offset = 0
    } = options,
          params = _objectWithoutProperties(options, ["parallelCount", "count", "offset"]);

    this.method = method;
    this.params = _objectSpread({}, params, {
      count: limit
    });

    if (parallelCount < 1 || parallelCount > 25) {
      throw new RangeError('The number of parallel calls can be between 1 and 25');
    }

    this.parallelCount = parallelCount;
    const hasMax = max !== null;
    const hasCount = count !== null;

    if (hasCount && hasMax && count > max || hasMax && !hasCount) {
      this.total = max;
    } else {
      this.total = count;
    }

    this.offset = offset;
    this.skipOffset = offset;
    this.received = 0;
    this.attempts = 0;
    this.promise = null;
    this.supportExecute = true;
    this.code = getExecuteCode({
      params: this.params,
      parallelCount,
      method
    });
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'CollectStream';
  }
  /**
   * Promise based
   *
   * @param {Function} thenFn
   * @param {Function} catchFn
   *
   * @return {Promise<Object>}
   */


  then(thenFn, catchFn) {
    if (this.promise === null) {
      let collect = [];
      this.promise = new Promise((resolve, reject) => {
        this.on('error', reject).on('end', () => resolve(collect)).on('data', ({
          items
        }) => {
          collect = [...collect, ...items];
        });
      });
    }

    return Promise.resolve(this.promise).then(thenFn, catchFn);
  }
  /**
   * Fetch data
   *
   * @return {Promise}
   */


  async _read() {
    const isNotFirst = this.total !== null && this.received !== 0;

    if (isNotFirst && this.total - this.skipOffset <= this.received) {
      this.push(null);
      return;
    }

    let items;

    if (!this.supportExecute || this.parallelCount === 1) {
      const request = new Request(this.method, _objectSpread({}, this.params, {
        offset: this.offset
      }));
      let result;

      try {
        result = await this.vk.api.callWithRequest(request);
      } catch (error) {
        const {
          collectAttempts
        } = this.vk.options;

        if (this.attempts >= collectAttempts) {
          this.emit('error', error);
          return;
        }

        this.attempts += 1; // eslint-disable-next-line no-underscore-dangle

        this._read();

        return;
      }

      const {
        count,
        items: collect
      } = result;

      if (this.total === null || this.total > count) {
        this.total = count;
      }

      items = collect;
    } else {
      let result;

      try {
        result = await this.vk.api.execute({
          code: this.code,
          total: this.total,
          offset: this.offset,
          received: this.received
        });
      } catch (error) {
        if (error.code === APP_TOKEN_NOT_VALID) {
          this.supportExecute = false;
          debug$7('execute not supported in token'); // eslint-disable-next-line no-underscore-dangle

          this._read();

          return;
        }

        if (error.code === RESPONSE_SIZE_TOO_BIG) {
          this.parallelCount -= 1;
          this.code = getExecuteCode({
            parallelCount: this.parallelCount,
            params: this.params,
            method: this.method
          }); // eslint-disable-next-line no-underscore-dangle

          this._read();

          return;
        }

        const {
          collectAttempts
        } = this.vk.options;

        if (this.attempts >= collectAttempts) {
          this.emit('error', error);
          return;
        }

        this.attempts += 1; // eslint-disable-next-line no-underscore-dangle

        this._read();

        return;
      }

      const {
        response,
        errors
      } = result;

      if (errors.length > 0) {
        this.emit('error', new CollectError({
          message: 'Execute error',
          code: EXECUTE_ERROR,
          errors
        }));
        return;
      }

      const {
        total,
        items: collect
      } = response;
      this.total = total;
      items = collect;
    }

    const {
      length
    } = items;

    if (length === 0) {
      this.push(null);
      return;
    }

    this.offset += length;
    this.received += length;
    const {
      total,
      received
    } = this;
    let percent = Math.round(received / total * 100);

    if (Number.isNaN(percent)) {
      percent = 100;
    }

    this.push({
      received,
      percent,
      total,
      items
    });
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$6.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      total,
      offset,
      received
    } = this;
    const payload = {
      total,
      offset,
      received
    };
    return `${options.stylize(name, 'special')} ${inspect$6(payload, options)}`;
  }

}

/**
 * List limits VK
 * Last updated 09.10.2017
 *
 * @type {Array}
 */
var LIMITS_METHODS = [
/**
 * Account
 */
['account.getActiveOffers', 100], ['account.getBanned', 200],
/**
 * Ads
 */
['ads.getAds', 100, 2000], ['ads.getAdsLayout', 100, 2000], ['ads.getAdsTargeting', 100, 2000],
/**
 * Apps
 */
['apps.getCatalog', 100], ['apps.getFriendsList', 5000],
/**
 * Audio
 */
['audio.get', 6000], ['audio.search', 300, 1000], ['audio.getAlbums', 100], ['audio.getRecommendations', 1000], ['audio.getPopular', 1000],
/**
 * Board
 */
['board.getComments', 100], ['board.getTopics', 100],
/**
 * Database
 */
['database.getChairs', 10000], ['database.getCities', 1000], ['database.getCountries', 1000], ['database.getFaculties', 10000], ['database.getRegions', 1000], ['database.getSchools', 10000], ['database.getUniversities', 10000],
/**
 * Docs
 */
['docs.get', 2000, 2000], ['docs.search', 1000, 1000],
/**
 * Fave
 */
['fave.getLinks', 100], ['fave.getMarketItems', 100], ['fave.getPhotos', 100], ['fave.getUsers', 100], ['fave.getVideos', 100],
/**
 * Friends
 */
['friends.get', 1000], ['friends.getMutual', 1000], ['friends.getMutual', 1000], ['friends.getOnline', 1000], ['friends.getRecent', 1000], ['friends.getRequests', 1000], ['friends.getSuggestions', 500], ['friends.search', 1000],
/**
 * Gifts
 */
['gifts.get', 100],
/**
 * Groups
 */
['groups.get', 1000], ['groups.getBanned', 200], ['groups.getInvitedUsers', 100], ['groups.getInvites', 100], ['groups.getMembers', 1000], ['groups.getRequests', 200],
/**
 * Leads
 */
['leads.getUsers', 1000],
/**
 * Likes
 */
['likes.getList', 100],
/**
 * Market
 */
['market.get', 200], ['market.getAlbums', 100], ['market.getCategories', 1000], ['market.getComments', 100], ['market.search', 200],
/**
 * messages
 */
['messages.get', 200], ['messages.getDialogs', 200], ['messages.getHistory', 200], ['messages.search', 100],
/**
 * Notes
 */
['notes.get', 100], ['notes.getComments', 100],
/**
 * Orders
 */
['orders.get', 1000],
/**
 * Photos
 */
['photos.get', 1000], ['photos.getAlbums', 100], ['photos.getAll', 200], ['photos.getAllComments', 100], ['photos.getComments', 100], ['photos.getNewTags', 100], ['photos.getUserPhotos', 1000], ['photos.search', 1000],
/**
 * Places
 */
['places.getCheckins', 100], ['places.search', 1000],
/**
 * Polls
 */
['polls.getVoters', 100],
/**
 * Storage
 */
['storage.getKeys', 1000],
/**
 * Users
 */
['users.getFollowers', 1000], ['users.getSubscriptions', 200], ['users.search', 1000, 1000],
/**
 * Utils
 */
['utils.getLastShortenedLinks', 50],
/**
 * Video
 */
['video.get', 200], ['video.getAlbums', 100], ['video.getComments', 100], ['video.search', 1000, 1000],
/**
 * Wall
 */
['wall.get', 100], ['wall.getComments', 100], ['wall.getReposts', 1000], ['wall.search', 100],
/**
 * Widgets
 */
['widgets.getComments', 200], ['widgets.getPages', 200]];

const {
  inspect: inspect$7
} = nodeUtil;
class Chain {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.queue = [];
    this.started = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Chain';
  }
  /**
   * Adds method to queue
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<mixed>}
   */


  append(method, params) {
    if (this.started) {
      throw new Error('Chain already started');
    }

    const request = new Request(method, params);
    this.queue.push(request);
    return request.promise;
  }
  /**
   * Promise based
   *
   * @param {Function} thenFn
   * @param {Function} catchFn
   *
   * @return {Promise<Object>}
   */


  then(thenFn, catchFn) {
    return Promise.resolve(this.run()).then(thenFn, catchFn);
  }
  /**
   * Starts the chain
   *
   * @return {Promise}
   */


  async run() {
    if (this.started) {
      throw new Error('Chain already started');
    }

    this.started = true;
    const {
      queue
    } = this;

    if (queue.length === 0) {
      return [];
    }

    let out = {
      response: [],
      errors: []
    };

    while (queue.length > 0) {
      const tasks = queue.splice(0, 25);
      const code = getChainReturn(tasks.map(String));

      try {
        const response = await this.vk.api.execute({
          code
        });
        resolveExecuteTask(tasks, response);
        out = {
          response: [...out.response, ...response.response],
          errors: [...out.errors, ...response.errors]
        };
      } catch (error) {
        for (const task of tasks) {
          task.reject(error);
        }

        throw error;
      }
    }

    return out;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$7.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      queue
    } = this;
    const payload = {
      started,
      queue
    };
    return `${options.stylize(name, 'special')} ${inspect$7(payload, options)}`;
  }

}

const {
  inspect: inspect$8
} = nodeUtil;
class Collect {
  /**
   * constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;

    for (const [method, limit, max] of LIMITS_METHODS) {
      const [group, name] = method.split('.');

      if (!(group in this)) {
        this[group] = {};
      }

      this[group][name] = (options = {}) => new CollectStream(this.vk, {
        options,
        method,
        limit,
        max
      });
    }
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Collect';
  }
  /**
   * Returns new Chain instance
   *
   * @return {Chain}
   */


  chain() {
    return new Chain(this.vk);
  }
  /**
   * Call multiple executors
   *
   * @param {string} method
   * @param {Array}  queue
   *
   * @return {Promise<Array>}
   */


  async executes(method, queue) {
    queue = queue.map(params => getExecuteMethod(method, params));
    const promises = [];

    while (queue.length !== 0) {
      const code = getChainReturn(queue.splice(0, 25));
      promises.push(this.vk.api.execute({
        code
      }));
    }

    let out = {
      response: [],
      errors: []
    };

    for (const _ref of await Promise.all(promises)) {
      const {
        response,
        errors
      } = _ref;
      out = {
        response: [...out.response, ...response],
        errors: [...out.errors, ...errors]
      };
    }

    return out;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$8.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} {}`;
  }

}

const {
  inspect: inspect$9
} = nodeUtil;
/**
 * Middleware stack
 *
 * @public
 */

class Middleware {
  /**
   * Constructor
   *
   * @param {Array} middlewares
   */
  constructor(...middlewares) {
    this.stack = [];
    this.use(middlewares);
  }
  /**
   * Adds middlewares
   *
   * @param {Array} middlewares
   *
   * @return {this}
   */


  use(...middlewares) {
    for (const middleware of middlewares) {
      if (Array.isArray(middleware)) {
        this.use(...middleware);
        continue;
      }

      if (typeof middleware !== 'function') {
        throw new TypeError('Middleware must be composed of functions!');
      }

      this.stack.push(middleware);
    }

    return this;
  }
  /**
   * Launches the middleware chain
   *
   * @param {Array} args
   *
   * @return {Promise<boolean>}
   */


  run(...args) {
    const {
      stack
    } = this;
    let index = -1;
    const status = {
      finished: true,
      contexts: args
    };

    const next = async i => {
      if (i <= index) {
        throw new Error('next() called multiple times');
      }

      index = i;
      const middleware = stack[i];

      if (!middleware) {
        status.finished = true;
        return status;
      }

      await middleware(...args, () => next(i + 1));
      status.finished = stack.length <= index;
      return status;
    };

    return next(0);
  }
  /**
   * Custom inspect object
   *
   * @param {?Number} depth
   * @param {Object}  options
   *
   * @return {String}
   */


  [inspect$9.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} { ${inspect$9(this.stack, options)} }`;
  }

}

const {
  inspect: inspect$10
} = nodeUtil;
class Context {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.type = null;
    this.subTypes = [];
    this.state = {};
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Checks whether the context of some of these types
   *
   * @param {string[]} types
   *
   * @return {boolean}
   */


  is(types) {
    if (!Array.isArray(types)) {
      types = [types];
    }

    return [this.type, ...this.subTypes].some(type => types.includes(type));
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$10.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} ${inspect$10(_objectSpread({}, this, {
      vk: '<VK>'
    }), options)}`;
  }

}

class VoteContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.type = 'vote';
    this.subTypes = ['pull_vote'];
    this.$groupId = groupId;
  }
  /**
   * Returns the identifier poll
   *
   * @return {number}
   */


  getId() {
    return this.payload.poll_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the identifier owner
   *
   * @return {number}
   */


  getOwnerId() {
    return this.payload.owner_id;
  }
  /**
   * Returns the identifier option
   *
   * @return {number}
   */


  getOptionId() {
    return this.payload.option_id;
  }

}

class TypingContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, user, extra]) {
    super(vk);
    const isChat = eventId === 62;
    this.payload = {
      user_id: user,
      chat_id: isChat ? extra : null,
      peer_id: isChat ? extra + CHAT_PEER : user
    };
    this.type = 'typing';
    this.subTypes = [eventId === 61 ? 'typing_dm' : 'typing_chat'];
  }
  /**
   * Checks that the message is typed in the dm
   *
   * @return {boolean}
   */


  isDM() {
    return this.subTypes.includes('typing_dm');
  }
  /**
   * Checks that the message is typed in the chat
   *
   * @return {boolean}
   */


  isChat() {
    return this.subTypes.includes('typing_chat');
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the identifier chat
   *
   * @return {?number}
   */


  getChatId() {
    return this.payload.chat_id;
  }

}

const lt = /&lt;/g;
const qt = /&gt;/g;
const br = /<br>/g;
const amp = /&amp;/g;
const quot = /&quot;/g;
/**
 * Decodes HTML entities
 *
 * @param {string} text
 *
 * @return {string}
 */

const unescapeHTML = text => text.replace(lt, '<').replace(qt, '>').replace(br, '\n').replace(amp, '&').replace(quot, '"');
/**
 * Separates a string through a separator
 *
 * @param {string} raw
 * @param {string} delimiter
 *
 * @return {Array}
 */

const splitFwdDelimiter = (raw, delimiter) => {
  const out = [];
  let tmp = '';
  let left = 0;
  let right = 0;

  const keepResult = () => {
    out.push(tmp);
    tmp = '';
  };

  for (const sign of raw) {
    // eslint-disable-next-line default-case
    switch (sign) {
      case delimiter:
        if (left === right) {
          left = 0;
          right = 0;
          keepResult();
          continue;
        }

        break;

      case '(':
        left += 1;
        break;

      case ')':
        right += 1;
    }

    tmp += sign;
  }

  keepResult();
  return out;
};
/**
 * Parse the sent forwards messages
 *
 * @param {string} raw
 *
 * @return {Array}
 */

const parseFwds = raw => {
  const out = [];

  for (const block of splitFwdDelimiter(raw, ',')) {
    const pair = splitFwdDelimiter(block, ':');

    if (pair.length === 0) {
      continue;
    }

    const [owner, id] = pair[0].split('_');
    const fwd = {
      id: Number(id),
      user_id: Number(owner),
      fwd_messages: []
    };

    if (pair.length !== 2) {
      out.push(fwd);
      continue;
    }

    fwd.fwd_messages = parseFwds(pair[1].substring(1, pair[1].length - 1));
    out.push(fwd);
  }

  return out;
};

/**
 * Special attachments in one message
 *
 * @type {Object}
 */

const specialAttachments = {
  sticker: raw => ({
    type: 'sticker',
    sticker: {
      sticker_id: Number(raw.attach1),
      product_id: Number(raw.attach1_product_id)
    }
  }),
  money_transfer: raw => ({
    type: 'money_transfer',
    money_transfer: {
      data: raw.attach1,
      amount: Number(raw.attach1_amount),
      currency: Number(raw.attach1_currency)
    }
  }),
  gift: raw => ({
    type: 'gift',
    gift: {
      id: Number(raw.attach1)
    }
  })
};
/**
 * Transform message to Object
 *
 * @param {Array} update
 *
 * @return {Object}
 */
// eslint-disable-next-line import/prefer-default-export

function transformMessage([, id, flags, peer, date, body, extra, attachments]) {
  const message = {
    id,
    date,
    body,
    flags,
    geo: 'geo' in attachments ? {} : null,
    random_id: extra.random_id || null,
    out: Number((flags & 2) === 2),
    deleted: Number((flags & 128) === 128),
    read_state: Number((flags & 1) === 1),
    emoji: Number(Boolean(extra.emoji))
  };
  const isGroup = peer < 0;
  const isChat = peer > CHAT_PEER;

  if (isGroup) {
    message.out = Number((flags & 2) === 0);
    message.important = Number((flags & 1) !== 0);
  } else {
    message.out = Number((flags & 2) !== 0);
    message.important = Number((flags & 8) !== 0);
  }

  if (isChat) {
    message.user_id = Number(extra.from);
    message.chat_id = peer - CHAT_PEER;
    message.title = extra.title;

    if ('source_act' in extra) {
      message.action = extra.source_act;
      message.action_mid = extra.source_mid;
      message.action_text = extra.source_text;
    }
  } else {
    message.user_id = peer;
  }

  if ('attach1' in attachments && attachments.attach1_type in specialAttachments) {
    message.attachments = [specialAttachments[attachments.attach1_type](attachments)];
  } else {
    message.attachments = [];

    for (let i = 1, key = 'attach1'; key in attachments; i += 1, key = `attach${i}`) {
      const type = attachments[`${key}_type`];

      if (type === 'link') {
        const attachment = {
          type: 'link',
          link: {
            url: attachments[`${key}_url`],
            title: attachments[`${key}_title`],
            description: attachments[`${key}_desc`]
          }
        };
        const photoKey = `${key}_photo`;

        if (attachments[photoKey]) {
          const [owner, attachmentId] = attachments[photoKey].split('_');
          attachment.link.photo = {
            id: Number(attachmentId),
            owner_id: Number(owner)
          };
        }

        message.attachments.push(attachment);
        continue;
      }

      const [owner, attachmentId] = attachments[key].split('_');
      const attachment = {
        type,
        [type]: {
          id: Number(attachmentId),
          owner_id: Number(owner)
        }
      };
      const kindKey = `${key}_kind`;

      if (type === 'doc' && kindKey in attachments) {
        attachment[type].kind = attachments[kindKey];
      }

      message.attachments.push(attachment);
    }
  }

  if ('fwd' in attachments) {
    message.fwd_messages = parseFwds(attachments.fwd);
  }

  return message;
}

const attachmentsTypes = ['doc', 'gift', 'link', 'wall', 'photo', 'video', 'audio', 'market', 'sticker', 'wall_reply', 'market_album'];
class MessageContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    source,
    updateType,
    groupId = null
  }) {
    super(vk);
    const isPolling = source === updatesSources.POLLING;
    const isWebhook = source === updatesSources.WEBHOOK;

    if (isPolling) {
      payload = transformMessage(payload);
    }

    this.payload = payload;
    let peerId;
    let peerType;

    if ('chat_id' in payload) {
      peerId = payload.chat_id + CHAT_PEER;
      peerType = 'chat';
    } else {
      peerId = payload.user_id;

      if (peerId < 0) {
        peerType = 'group';
      } else {
        peerType = 'dm';
      }
    }

    this.from = {
      id: peerId,
      type: peerType
    };
    this.text = this.payload.body ? unescapeHTML(this.payload.body) : null;
    this.attachments = transformAttachments(payload.attachments, vk);
    const subTypes = attachmentsTypes.filter(type => this.attachments.some(attachment => attachment.getType() === type));

    if (!this.isEvent()) {
      if (isWebhook) {
        subTypes.push(updateType === 'message_edit' ? 'edit_message' : 'new_message');
      } else if (isPolling) {
        subTypes.push(updateType === 5 ? 'edit_message' : 'new_message');
      }
    }

    if (this.hasText()) {
      subTypes.push('text');
    }

    if ('action' in this.payload) {
      subTypes.push(this.payload.action);
    }

    this.type = 'message';
    this.subTypes = subTypes;
    this.$groupId = groupId;
    this.filled = isWebhook;
  }
  /**
   * Load message payload
   *
   * @return {Promise}
   */


  async loadMessagePayload() {
    if (this.filled) {
      return;
    }

    const {
      items
    } = await this.vk.api.messages.getById({
      message_ids: this.getId()
    });
    const [message] = items;
    this.payload = message;
    this.attachments = transformAttachments(message.attachments, this.vk);
    this.filled = true;
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Checks if there is text
   *
   * @return {boolean}
   */


  hasText() {
    return this.text !== null;
  }
  /**
   * Checks for forwarded messages
   *
   * @return {boolean}
   */


  hasForwards() {
    return 'fwd_messages' in this.payload;
  }
  /**
   * Checks if there is text
   *
   * @return {boolean}
   */


  hasGeo() {
    return Boolean(this.payload.geo);
  }
  /**
   * Checks is a DM
   *
   * @return {boolean}
   */


  isDM() {
    return this.from.type === 'dm';
  }
  /**
   * Checks is a chat
   *
   * @return {boolean}
   */


  isChat() {
    return this.from.type === 'chat';
  }
  /**
   * Checks is a group
   *
   * @return {boolean}
   */


  isGroup() {
    return this.from.type === 'group';
  }
  /**
   * Check is special event
   *
   * @return {boolean}
   */


  isEvent() {
    return this.isChat() && Boolean(this.payload.action);
  }
  /**
   * Checks whether the message is outbox
   *
   * @return {boolean}
   */


  isOutbox() {
    return Boolean(this.payload.out);
  }
  /**
   * Checks whether the message is inbox
   *
   * @return {boolean}
   */


  isInbox() {
    return !this.isOutbox();
  }
  /**
   * Checks that the message was deleted
   *
   * @return {boolean}
   */


  isDeleted() {
    return Boolean(this.payload.deleted);
  }
  /**
   * Checks whether the message is read
   *
   * @return {boolean}
   */


  isRead() {
    return Boolean(this.payload.read_state);
  }
  /**
   * Checks that the message is important
   *
   * @return {boolean}
   */


  isImportant() {
    return Boolean(this.payload.important);
  }
  /**
   * Returns the identifier message
   *
   * @return {number}
   */


  getId() {
    return this.payload.id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the sender identifier
   *
   * @return {number}
   */


  getSenderId() {
    return this.payload.from_id || this.getUserId() || null;
  }
  /**
   * Returns the identifier chat
   *
   * @return {?number}
   */


  getChatId() {
    if (!this.isChat()) {
      return null;
    }

    return this.payload.chat_id;
  }
  /**
   * Returns the destination identifier
   *
   * @return {number}
   */


  getPeerId() {
    return this.from.id;
  }
  /**
   * Returns the timestamp when this message was created
   *
   * @return {number}
   */


  getTimestamp() {
    return this.payload.date;
  }
  /**
   * Returns the Date object when this message was created
   *
   * @return {Date}
   */


  getDate() {
    return new Date(this.payload.date);
  }
  /**
   * Returns the chat title
   *
   * @return {string}
   */


  getTitle() {
    return this.payload.title || null;
  }
  /**
   * Returns the text
   *
   * @return {?string}
   */


  getText() {
    return this.text;
  }
  /**
   * Returns the from
   *
   * @return {Object}
   */


  getFrom() {
    return this.from;
  }
  /**
   * Returns the forwards messages
   *
   * @return {Object[]}
   */


  getForwards() {
    return this.payload.fwd_messages || [];
  }
  /**
   * Returns geo
   *
   * @return {?Object}
   */


  getGeo() {
    if (!this.hasGeo()) {
      return null;
    }

    if (!this.filled) {
      throw new Error('The message payload is not fully loaded');
    }

    return this.payload.geo;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }
  /**
   * Returns the event id
   *
   * @type {Object}
   */


  getEventId() {
    return this.payload.action_mid || null;
  }
  /**
   * Returns the event name
   *
   * @return {?string}
   */


  getEventType() {
    return this.payload.action || null;
  }
  /**
   * Returns the event name
   *
   * @return {?string}
   */


  getEventText() {
    return this.payload.action_text || null;
  }
  /**
   * Gets a link to invite the user to a conversation
   *
   * @param {Object} params
   *
   * @type {Promise<Object>}
   */


  getInviteLink(params = {}) {
    return this.vk.api.messages.getInviteLink(_objectSpread({}, params, {
      peer_id: this.getPeerId()
    }));
  }
  /**
   * Edits a message
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  editMessage(params) {
    return this.vk.api.messages.edit(_objectSpread({}, params, {
      peer_id: this.getPeerId(),
      message_id: this.getId()
    }));
  }
  /**
   * Edits a message text
   *
   * @param {string} message
   *
   * @return {Promise}
   */


  async editMessageText(message) {
    try {
      const response = await this.editMessage({
        message
      });
      this.text = message;
      return response;
    } catch (e) {
      throw e;
    }
  }
  /**
   * Sends a message to the current dialog
   *
   * @param {string|Object} text
   * @param {Object}        params
   *
   * @return {Promise}
   */


  send(text, params = {}) {
    if (typeof text !== 'object') {
      params.message = text;
    } else {
      params = text;
    }

    params.peer_id = this.from.id;
    return this.vk.api.messages.send(params);
  }
  /**
   * Responds to the current message
   *
   * @param {string|Object} text
   * @param {Object}        params
   *
   * @return {Promise}
   */


  reply(text, params = {}) {
    if (typeof text !== 'object') {
      params.message = text;
    } else {
      params = text;
    }

    params.forward_messages = this.payload.id;
    return this.send(params);
  }
  /**
   * Sends a sticker to the current dialog
   *
   * @param {number} id
   *
   * @return {Promise}
   */


  sendSticker(id) {
    return this.send({
      sticker_id: id
    });
  }
  /**
   * Sends a photo to the current dialog
   *
   * @param {mixed}  sourxe
   * @param {Object} params
   *
   * @return {Promise}
   */


  async sendPhoto(source, params = {}) {
    const attachment = await this.vk.upload.messagePhoto({
      peer_id: this.getPeerId(),
      source
    });
    return await this.send(_objectSpread({}, params, {
      attachment
    }));
  }
  /**
   * Sends a document to the current dialog
   *
   * @param {mixed}  sourxe
   * @param {Object} params
   *
   * @return {Promise}
   */


  async sendDocument(source, params = {}) {
    const attachment = await this.vk.upload.messageDocument({
      peer_id: this.getPeerId(),
      source
    });
    return await this.send(_objectSpread({}, params, {
      attachment
    }));
  }
  /**
   * Sends a voice to the current dialog
   *
   * @param {mixed}  sourxe
   * @param {Object} params
   *
   * @return {Promise}
   */


  async sendVoice(source, params = {}) {
    const attachment = await this.vk.upload.voice({
      peer_id: this.getPeerId(),
      source
    });
    return await this.send(_objectSpread({}, params, {
      attachment
    }));
  }
  /**
   * Changes the status of typing in the dialog
   *
   * @return {Promise<boolean>}
   */


  async setActivity() {
    const isActivited = await this.vk.api.messages.setActivity({
      peer_id: this.from.id,
      type: 'typing'
    });
    return Boolean(isActivited);
  }
  /**
   * Marks messages as important or removes a mark.
   *
   * @param {Array}  ids
   * @param {Object} options
   *
   * @return {Promise<Array>}
   */


  async markAsImportant(ids = [this.getId()], options = {
    important: Number(!this.isImportant())
  }) {
    const messageIds = await this.vk.api.messages.markAsImportant(_objectSpread({}, options, {
      message_ids: ids.join(',')
    }));

    if (messageIds.includes(this.getId())) {
      this.payload.important = options.important;
    }

    return messageIds;
  }
  /**
   * Deletes the message
   *
   * @param {Array}  ids
   * @param {Object} options
   *
   * @return {Promise<number[]>}
   */


  async deleteMessage(ids = [this.getId()], options = {
    spam: 0
  }) {
    let messageIds = await this.vk.api.messages.delete(_objectSpread({}, options, {
      message_ids: ids.join(',')
    }));
    messageIds = Object.entries(messageIds).filter(([, value]) => Boolean(value)).map(([key]) => key);

    if (messageIds.includes(this.getId())) {
      this.payload.delete = 1;
    }

    return messageIds;
  }
  /**
   * Restores the message
   *
   * @return {Promise<boolean>}
   */


  async restoreMessage() {
    const isRestored = await this.vk.api.messages.restore({
      message_id: this.payload.id
    });

    if (this.isDeleted() && isRestored) {
      this.payload.deleted = 0;
    }

    return Boolean(isRestored);
  }
  /**
   * Allows you to join the chat by an invitation link
   *
   * @param {string} params
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  joinChatByInviteLink(link, params = {}) {
    return this.vk.api.messages.joinChatByInviteLink(_objectSpread({}, params, {
      link
    }));
  }
  /**
   * Checks that in a chat
   */


  assertIsChat() {
    if (!this.isChat()) {
      throw new Error('This method is only available in chat');
    }
  }
  /**
   * Rename the chat
   *
   * @param {string} title
   *
   * @return {Promise<boolean>}
   */


  async renameChat(title) {
    this.assertIsChat();
    const isRenamed = await this.vk.api.messages.editChat({
      chat_id: this.getChatId(),
      title
    });
    return Boolean(isRenamed);
  }
  /**
   * Sets a new image for the chat
   *
   * @param {mixed}  source
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  async newChatPhoto(source, params = {}) {
    this.assertIsChat();
    return await this.vk.upload.chatPhoto(_objectSpread({}, params, {
      chat_id: this.getChatId(),
      source
    }));
  }
  /**
   * Remove the chat photo
   *
   * @return {Promise<boolean>}
   */


  async deleteChatPhoto() {
    this.assertIsChat();
    return this.vk.api.messages.deleteChatPhoto({
      chat_id: this.getChatId()
    });
  }
  /**
   * Invites a new user
   *
   * @param {number} id
   *
   * @return {Promise<boolean>}
   */


  async inviteUser(id = this.getEventId()) {
    this.assertIsChat();
    const isInvited = await this.vk.api.messages.removeChatUser({
      chat_id: this.getChatId(),
      user_id: id
    });
    return Boolean(isInvited);
  }
  /**
   * Excludes user
   *
   * @param {number} id
   *
   * @return {Promise<boolean>}
   */


  async kickUser(id = this.getEventId()) {
    this.assertIsChat();
    const isKicked = await this.vk.api.messages.removeChatUser({
      chat_id: this.getChatId(),
      user_id: id
    });
    return Boolean(isKicked);
  }
  /**
   * Pins a message
   *
   * @return {Promise<boolean>}
   */


  async pinMessage() {
    this.assertIsChat();
    const isPinned = await this.vk.api.messages.pin({
      peer_id: this.getPeerId(),
      message_id: this.getId()
    });
    return Boolean(isPinned);
  }
  /**
   * Unpins a message
   *
   * @return {Promise<boolean>}
   */


  async unpinMessage() {
    this.assertIsChat();
    const isUnpinned = await this.vk.api.messages.unpin({
      peer_id: this.getPeerId(),
      message_id: this.getId()
    });
    return Boolean(isUnpinned);
  }

}

class WallPostContext extends Context {
  /**
   * constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.attachments = [new WallAttachment(payload, vk)];
    this.type = 'wall_post';
    this.subTypes = [updateType === 'wall_post_new' ? 'new_wall_post' : 'new_wall_repost'];
    this.$groupId = groupId;
  }
  /**
   * Checks is repost
   *
   * @return {boolean}
   */


  isRepost() {
    return this.subTypes.includes('new_wall_repost');
  }
  /**
   * Returns the wall attachment
   *
   * @return {WallAttachment}
   */


  getWall() {
    return this.attachments[0];
  }
  /**
   * Removes a record from the wall
   *
   * @return {Promise}
   */


  deletePost() {
    const wall = this.getWall();
    return this.vk.api.wall.delete({
      post_id: wall.getId(),
      owner_id: wall.getOwnerId()
    });
  }

}

class StreamingContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload) {
    super(vk);
    this.payload = payload;
    const {
      action,
      event_type: type
    } = payload;
    this.attachments = transformAttachments(payload.attachments, vk);
    this.type = 'publication';
    this.subTypes = [`publication_${type}`, `${action}_publication`, `${action}_publication_${type}`];
  }
  /**
   * Checks is new object
   *
   * @return {boolean}
   */


  isNew() {
    return this.payload.action === 'new';
  }
  /**
   * Checks is update object
   *
   * @return {boolean}
   */


  isUpdate() {
    return this.payload.action === 'update';
  }
  /**
   * Checks is delete object
   *
   * @return {boolean}
   */


  isDelete() {
    return this.payload.action === 'delete';
  }
  /**
   * Checks is restore object
   *
   * @return {boolean}
   */


  isRestore() {
    return this.payload.action === 'restore';
  }
  /**
   * Checks is post event
   *
   * @return {boolean}
   */


  isPost() {
    return this.payload.event_type === 'post';
  }
  /**
   * Checks is share event
   *
   * @return {boolean}
   */


  isShare() {
    return this.payload.event_type === 'share';
  }
  /**
   * Checks is comment event
   *
   * @return {boolean}
   */


  isComment() {
    return this.payload.event_type === 'comment';
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Returns the event URL
   *
   * @return {string}
   */


  getUrl() {
    return this.payload.event_url;
  }
  /**
   * Returns the creation time
   *
   * @return {number}
   */


  getDate() {
    return this.payload.creation_time;
  }
  /**
   * Returns the text of the post
   *
   * @return {string}
   */


  getText() {
    return this.payload.text;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }
  /**
   * Returns the text of the shared post
   *
   * @return {?string}
   */


  getSharedText() {
    return this.payload.shared_post_text || null;
  }
  /**
   * Returns the creation time from original post
   *
   * @return {?number}
   */


  getSharedDate() {
    return this.payload.shared_post_creation_time || null;
  }
  /**
   * Returns the action type
   *
   * @return {string}
   */


  getActionType() {
    return this.payload.action;
  }
  /**
   * Returns the creation time from
   *
   * @return {number}
   */


  getActionDate() {
    return this.payload.action_time;
  }
  /**
   * Returns the geo location
   *
   * @return {Object}
   */


  getGeo() {
    return this.payload.geo;
  }
  /**
   * Returns the rule tags
   *
   * @return {Array}
   */


  getTags() {
    return this.payload.tags;
  }
  /**
   * Returns the identifier signer user
   *
   * @return {number}
   */


  getSignerId() {
    return this.payload.signer_id;
  }
  /**
   * Returns the information of author
   *
   * @return {Object}
   */


  getAuthor() {
    return this.payload.author;
  }
  /**
   * Returns the identifier author
   *
   * @return {number}
   */


  getAuthorId() {
    return this.payload.author.id;
  }
  /**
   * Returns the author url
   *
   * @return {string}
   */


  getAuthorUrl() {
    return this.payload.author.author_url;
  }
  /**
   * Returns the identifier of the author of the original post
   *
   * @return {?number}
   */


  getSharedAuthorId() {
    return this.payload.author.shared_post_author_id || null;
  }
  /**
   * Returns the author url of the original post
   *
   * @return {?string}
   */


  getSharedAuthorUrl() {
    return this.payload.author.shared_post_author_url || null;
  }
  /**
   * Returns the author platform
   *
   * @return {?string}
   */


  getAuthorPlatform() {
    return platforms.get(this.payload.author.platform);
  }

}

/**
 * Causes of blocking
 *
 * @type {Map}
 */

const reasonNames = new Map([[0, 'other'], [1, 'spam'], [2, 'members_insult'], [3, 'obscene_expressions'], [4, 'messages_off_topic']]);
class GroupUserContext extends Context {
  /**
   * Constructror
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.type = 'group_user';
    this.subTypes = [updateType === 'user_block' ? 'block_group_user' : 'unblock_group_user'];
    this.$groupId = groupId;
  }
  /**
   * Checks is join user
   *
   * @return {boolean}
   */


  isBlock() {
    return this.subTypes.includes('block_group_user');
  }
  /**
   * Checks is leave user
   *
   * @return {boolean}
   */


  isUnblock() {
    return this.subTypes.includes('unblock_group_user');
  }
  /**
   * Checks that the block has expired
   *
   * @return {?boolean}
   */


  isExpired() {
    if (this.isBlock()) {
      return null;
    }

    return Boolean(this.payload.by_end_date);
  }
  /**
   * Returns the identifier admin
   *
   * @return {?number}
   */


  getAdminId() {
    return this.payload.admin_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the reason for the ban
   *
   * @return {?number}
   */


  getReasonId() {
    return this.payload.reason || null;
  }
  /**
   * Returns the reason name for the ban
   *
   * @return {?string}
   */


  getReasonName() {
    return reasonNames.get(this.payload.reason);
  }
  /**
   * Returns the administrator comment to block
   *
   * @return {?string}
   */


  getComment() {
    return this.payload.comment || null;
  }
  /**
   * Adds a user to the community blacklist
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  banUser(params) {
    if (this.isBlock()) {
      return Promise.reject(new Error('User is blocked'));
    }

    return this.vk.api.groups.banUser(_objectSpread({}, params, {
      group_id: this.$groupId,
      user_id: this.payload.user_id
    }));
  }
  /**
   * Adds a user to the community blacklist
   *
   * @return {Promise}
   */


  unbanUser() {
    if (this.isUnblock()) {
      return Promise.reject(new Error('User is not blocked'));
    }

    return this.vk.api.groups.unbanUser({
      group_id: this.$groupId,
      user_id: this.payload.user_id
    });
  }

}

class UserOnlineContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, user, extra, date]) {
    super(vk);
    this.payload = {
      user_id: -user,
      extra,
      date
    };
    this.type = 'user_active';
    this.subTypes = [eventId === 8 ? 'user_online' : 'user_offline'];
  }
  /**
   * Checks that the user is online
   *
   * @return {boolean}
   */


  isUserOnline() {
    return this.subTypes.includes('user_online');
  }
  /**
   * Checks that the user is online
   *
   * @return {boolean}
   */


  isUserOffline() {
    return this.subTypes.includes('user_offline');
  }
  /**
   * Checks that the user has logged out of the network himself
   *
   * @return {boolean}
   */


  isSelfExit() {
    return this.isUserOffline() && !this.payload.extra;
  }
  /**
   * Checks that the user logged out a timeout
   *
   * @return {boolean}
   */


  isTimeoutExit() {
    return this.isUserOffline() && Boolean(this.payload.extra);
  }
  /**
   * Returns the date when this event was created
   *
   * @return {number}
   */


  getDate() {
    return this.payload.date;
  }
  /**
   * Returns the name of the platform from which the user entered
   *
   * @return {?string}
   */


  getPlatformName() {
    return platforms.get(this.payload.extra);
  }

}

class DialogFlagsContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, peer, flags]) {
    super(vk);
    this.payload = {
      peer_id: peer,
      flags
    };
    this.type = 'dialog_flags';
    this.subTypes = [// eslint-disable-next-line no-nested-ternary
    eventId === 10 ? 'remove_dialog_flags' : eventId === 11 ? 'update_dialog_flags' : 'set_dialog_flags'];
  }
  /**
   * Checks that an important dialogue
   *
   * @return {boolean}
   */


  isImportant() {
    return Boolean(this.payload.flags & 1);
  }
  /**
   * Checks that the unanswered dialog
   *
   * @return {boolean}
   */


  isUnanswered() {
    return Boolean(this.payload.flags & 2);
  }
  /**
   * Returns the destination identifier
   *
   * @return {number}
   */


  getPeerId() {
    return this.payload.peer_id;
  }
  /**
   * Returns the values of the flags
   *
   * @return {number}
   */


  getFlags() {
    return this.payload.flags;
  }
  /**
   * Marks the dialog as answered or unchecked.
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  markAsAnsweredDialog(params) {
    return this.vk.api.messages.markAsAnsweredDialog(_objectSpread({}, params, {
      peer_id: this.payload.peer_id
    }));
  }
  /**
   * Marks the dialog as important or removes the mark
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  markAsImportantDialog(params) {
    return this.vk.api.messages.markAsImportantDialog(_objectSpread({}, params, {
      peer_id: this.payload.peer_id
    }));
  }

}

class GroupUpdateContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    const isChangePhoto = updateType === 'group_change_photo';
    this.attachments = isChangePhoto ? [new PhotoAttachment(payload.photo, vk)] : [];
    this.type = 'group_update';
    this.subTypes = [// eslint-disable-next-line no-nested-ternary
    updateType === 'group_change_settings' ? 'group_update_settings' : isChangePhoto ? 'group_update_photo' : 'group_update_officers'];
    this.$groupId = groupId;
  }
  /**
   * Checks is change photo
   *
   * @return {boolean}
   */


  isChangePhoto() {
    return this.subTypes.includes('group_change_photo');
  }
  /**
   * Checks is change officers
   *
   * @return {boolean}
   */


  isChangeOfficers() {
    return this.subTypes.includes('group_change_officers');
  }
  /**
   * Checks is change settings
   *
   * @return {boolean}
   */


  isChangeSettings() {
    return this.subTypes.includes('group_change_settings');
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Returns the identifier admin
   *
   * @return {?number}
   */


  getAdminId() {
    return this.payload.admin_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the old level permission
   *
   * @return {?number}
   */


  getOldLevel() {
    return this.payload.level_old || null;
  }
  /**
   * Returns the new level permission
   *
   * @return {?number}
   */


  getNewLevel() {
    return this.payload.level_new || null;
  }
  /**
   * Returns the changes settings
   *
   * @return {?Object}
   */


  getChanges() {
    return this.payload.changes || null;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }

}

class GroupMemberContext extends Context {
  /**
   * Constructro
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.type = 'group_member';
    this.subTypes = [updateType === 'group_leave' ? 'leave_group_member' : 'join_group_member'];
    this.$groupId = groupId;
  }
  /**
   * Checks is join user
   *
   * @return {boolean}
   */


  isJoin() {
    return this.subTypes.includes('join_group_member');
  }
  /**
   * Checks is leave user
   *
   * @return {boolean}
   */


  isLeave() {
    return this.subTypes.includes('leave_group_member');
  }
  /**
   * Checks is self leave user
   *
   * @return {?boolean}
   */


  isSelfLeave() {
    if (this.isJoin()) {
      return null;
    }

    return Boolean(this.payload.self);
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the join type
   *
   * @return {?string}
   */


  getJoinType() {
    if (this.isLeave()) {
      return null;
    }

    return this.payload.join_type;
  }

}

class MessageAllowContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.type = 'message_subscribers';
    this.subTypes = [updateType === 'message_allow' ? 'message_subscribe' : 'message_unsubscribe'];
    this.$groupId = groupId;
  }
  /**
   * Checks that the user has subscribed to messages
   *
   * @return {boolean}
   */


  isSubscribed() {
    return this.subTypes.includes('message_subscribe');
  }
  /**
   * Checks that the user has unsubscribed from the messages
   *
   * @return {boolean}
   */


  isUbsubscribed() {
    return this.subTypes.includes('message_unsubscribe');
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  getUserId() {
    return this.payload.user_id;
  }
  /**
   * Returns the key
   *
   * @return {?string}
   */


  getKey() {
    return this.payload.key || null;
  }

}

class ReadMessagesContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, peer, id]) {
    super(vk);
    this.payload = {
      peer_id: peer,
      id
    };
    this.type = 'read_messages';
    this.subTypes = [eventId === 6 ? 'read_inbox_messages' : 'read_oubox_messages'];
  }
  /**
   * Checks that inbox messages are read
   *
   * @return {boolean}
   */


  isInbox() {
    return this.subTypes.includes('read_inbox_messages');
  }
  /**
   * Checks that outbox messages are read
   *
   * @return {boolean}
   */


  isOutbox() {
    return this.subTypes.includes('read_oubox_messages');
  }
  /**
   * Returns the ID before the message read
   *
   * @return {number}
   */


  getId() {
    return this.payload.id;
  }
  /**
   * Returns the peer ID
   *
   * @return {number}
   */


  getPeerId() {
    return this.payload.peer_id;
  }

}

class MessageFlagsContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, id, flags, peer]) {
    super(vk);
    this.payload = {
      peer_id: peer,
      flags,
      id
    };
    this.type = 'message_flags';
    this.subTypes = [// eslint-disable-next-line no-nested-ternary
    eventId === 1 ? 'update_message_flags' : eventId === 2 ? 'set_message_flags' : 'remove_message_flags'];
  }
  /**
   * Verifies that the message is not read
   *
   * @return {boolean}
   */


  isUnread() {
    return Boolean(this.payload.flags & 1);
  }
  /**
   * Checks that the outgoing message
   *
   * @return {boolean}
   */


  isOutbox() {
    return Boolean(this.payload.flags & 2);
  }
  /**
   * Verifies that a reply has been created to the message
   *
   * @return {boolean}
   */


  isReplied() {
    return Boolean(this.payload.flags & 4);
  }
  /**
   * Verifies that the marked message
   *
   * @return {boolean}
   */


  isImportant() {
    return Boolean(this.payload.flags & 8);
  }
  /**
   * Verifies that the message was sent via chat
   *
   * @return {boolean}
   */


  isChat() {
    return Boolean(this.payload.flags & 16);
  }
  /**
   * Verifies that the message was sent by a friend
   *
   * @return {boolean}
   */


  isFriends() {
    return Boolean(this.payload.flags & 32);
  }
  /**
   * Verifies that the message is marked as "Spam"
   *
   * @return {boolean}
   */


  isSpam() {
    return Boolean(this.payload.flags & 64);
  }
  /**
   * Verifies that the message has been deleted (in the Recycle Bin)
   *
   * @return {boolean}
   */


  isDeleted() {
    return Boolean(this.payload.flags & 128);
  }
  /**
   * Verifies that the message was verified by the user for spam
   *
   * @return {boolean}
   */


  isFixed() {
    return Boolean(this.payload.flags & 256);
  }
  /**
   * Verifies that the message contains media content
   *
   * @return {boolean}
   */


  isMedia() {
    return Boolean(this.payload.flags & 512);
  }
  /**
   * Checks that a welcome message from the community
   *
   * @return {boolean}
   */


  isHidden() {
    return Boolean(this.payload.flags & 65536);
  }
  /**
   * Returns the message ID
   *
   * @return {number}
   */


  getId() {
    return this.payload.id;
  }
  /**
   * Returns the destination identifier
   *
   * @return {number}
   */


  getPeerId() {
    return this.payload.peer_id;
  }
  /**
   * Returns the values of the flags
   *
   * @return {number}
   */


  getFlags() {
    return this.payload.flags;
  }

}

/**
 * Find types
 *
 * @example wall_reply_new
 *
 * @type {RegExp}
 */

const findTypes = /([^_]+)_([^_]+)_([^_]+)/;
class CommentActionContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.attachments = transformAttachments(payload.attachments, vk);
    const [, initsiator, commentType, action] = updateType.match(findTypes);
    this.type = 'comment';
    this.subTypes = [`${initsiator}_comment`, `${action}_${initsiator}_comment`];
    this.$groupId = groupId;
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Checks is new comment
   *
   * @return {boolean}
   */


  isNew() {
    return this.includesFromSubType('new');
  }
  /**
   * Checks is edit comment
   *
   * @return {boolean}
   */


  isEdit() {
    return this.includesFromSubType('edit');
  }
  /**
   * Checks is delete comment
   *
   * @return {boolean}
   */


  isDelete() {
    return this.includesFromSubType('delete');
  }
  /**
   * Checks is restore comment
   *
   * @return {boolean}
   */


  isRestore() {
    return this.includesFromSubType('restore');
  }
  /**
   * Checks is photo comment
   *
   * @return {boolean}
   */


  isPhotoComment() {
    return this.includesFromSubType('photo');
  }
  /**
   * Checks is wall comment
   *
   * @return {boolean}
   */


  isWallComment() {
    return this.includesFromSubType('wall');
  }
  /**
   * Checks is video comment
   *
   * @return {boolean}
   */


  isVideoComment() {
    return this.includesFromSubType('video');
  }
  /**
   * Checks is board comment
   *
   * @return {boolean}
   */


  isBoardComment() {
    return this.includesFromSubType('board');
  }
  /**
   * Checks is board comment
   *
   * @return {boolean}
   */


  isMarketComment() {
    return this.includesFromSubType('market');
  }
  /**
   * Checks is reply comment
   *
   * @return {boolean}
   */


  isReply() {
    return 'reply_to_comment' in this.payload;
  }
  /**
   * Returns the identifier comment
   *
   * @return {number}
   */


  getId() {
    return this.payload.id;
  }
  /**
   * Returns the identifier reply comment
   *
   * @return {?number}
   */


  getReplyId() {
    return this.payload.reply_to_comment || null;
  }
  /**
   * Returns the identifier user
   *
   * @return {?number}
   */


  getUserId() {
    return this.payload.from_id || this.payload.user_id || null;
  }
  /**
   * Returns the identifier reply user
   *
   * @return {?number}
   */


  getReplyUserId() {
    return this.payload.reply_to_user || null;
  }
  /**
   * Returns the identifier of the user who deleted the comment
   *
   * @return {?number}
   */


  getRemoverUserId() {
    return this.payload.deleter_id || null;
  }
  /**
   * Returns the identifier of object
   *
   * @return {?number}
   */


  getObjectId() {
    const {
      payload
    } = this;
    return payload.photo_id || payload.video_id || payload.post_id || payload.topic_id || payload.item_id || null;
  }
  /**
   * Returns the identifier of owner
   *
   * @return {?number}
   */


  getOwnerId() {
    const {
      payload
    } = this;
    return payload.owner_id || payload.photo_owner_id || payload.video_owner_id || payload.post_owner_id || payload.topic_owner_id || payload.market_owner_id || null;
  }
  /**
   * Returns the date creation action comment
   *
   * @return {?number}
   */


  getDate() {
    return this.payload.date || null;
  }
  /**
   * Returns the text comment
   *
   * @return {?string}
   */


  getText() {
    return this.payload.text || null;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }
  /**
   * Returns the likes
   *
   * @return {?Object}
   */


  getLikes() {
    return this.payload.likes;
  }
  /**
   * Includes from subtype
   *
   * @param {string} type
   *
   * @return {string}
   */


  includesFromSubType(type) {
    return this.subTypes[1].includes(type);
  }
  /**
   * Edits a comment
   *
   * @param {Object} options
   *
   * @return {Promise}
   */


  editComment(options) {
    if (this.isDelete()) {
      return Promise.reject(new Error('Comment is deleted'));
    }

    if (this.isBoardComment()) {
      return this.vk.api.board.editComment(_objectSpread({}, options, {
        topic_id: this.getObjectId(),
        comment_id: this.getId(),
        group_id: this.$groupId
      }));
    }

    const params = _objectSpread({}, options, {
      comment_id: this.getId(),
      owner_id: this.getOwnerId()
    });

    if (this.isPhotoComment()) {
      return this.vk.api.photos.editComment(params);
    }

    if (this.isVideoComment()) {
      return this.vk.api.video.editComment(params);
    }

    if (this.isWallComment()) {
      return this.vk.api.wall.editComment(params);
    }

    if (this.isMarketComment()) {
      return this.vk.api.market.editComment(params);
    }

    return Promise.reject(new Error('Unsupported event for editing comment'));
  }
  /**
   * Removes comment
   *
   * @return {Promise}
   */


  deleteComment() {
    if (this.isDelete()) {
      return Promise.reject(new Error('Comment is deleted'));
    }

    if (this.isBoardComment()) {
      return this.vk.api.board.deleteComment({
        topic_id: this.getObjectId(),
        comment_id: this.getId(),
        group_id: this.$groupId
      });
    }

    const params = {
      comment_id: this.getId(),
      owner_id: this.getOwnerId()
    };

    if (this.isPhotoComment()) {
      return this.vk.api.photos.deleteComment(params);
    }

    if (this.isVideoComment()) {
      return this.vk.api.video.deleteComment(params);
    }

    if (this.isWallComment()) {
      return this.vk.api.wall.deleteComment(params);
    }

    if (this.isMarketComment()) {
      return this.vk.api.market.deleteComment(params);
    }

    return Promise.reject(new Error('Unsupported event for deleting comment'));
  }

}

class NewAttachmentsContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    let subType;
    let attachment; // eslint-disable-next-line default-case

    switch (updateType) {
      case 'photo_new':
        {
          subType = 'new_photo_attachment';
          attachment = new PhotoAttachment(payload, vk);
          break;
        }

      case 'video_new':
        {
          subType = 'new_video_attachment';
          attachment = new VideoAttachment(payload, vk);
          break;
        }

      case 'audio_new':
        {
          subType = 'new_audio_attachment';
          attachment = new AudioAttachment(payload, vk);
          break;
        }
    }

    this.attachments = [attachment];
    this.type = 'new_attachment';
    this.subTypes = [subType];
    this.$groupId = groupId;
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }
  /**
   * Checks is attachment photo
   *
   * @return {boolean}
   */


  isPhoto() {
    return this.subTypes.includes('new_photo');
  }
  /**
   * Checks is attachment video
   *
   * @return {boolean}
   */


  isVideo() {
    return this.subTypes.includes('new_video');
  }
  /**
   * Checks is attachment audio
   *
   * @return {boolean}
   */


  isAudio() {
    return this.subTypes.includes('new_audio');
  }
  /**
   * Removes the attachment
   *
   * @return {Promise}
   */


  deleteAttachment() {
    if (this.isPhoto()) {
      const [photo] = this.getAttachments('photo');
      return this.vk.api.photos.delete({
        owner_id: photo.getOwnerId(),
        photo_id: photo.getId()
      });
    }

    if (this.isVideo()) {
      const [video] = this.getAttachments('video');
      return this.vk.api.video.delete({
        owner_id: video.getOwnerId(),
        video_id: video.getId()
      });
    }

    if (this.isAudio()) {
      const [audio] = this.getAttachments('audio');
      return this.vk.api.audio.delete({
        owner_id: audio.getOwnerId(),
        audio_id: audio.getId()
      });
    }

    return Promise.reject(new Error('Unsupported event for deleting attachment'));
  }

}

class RemovedMessagesContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Arrray} payload
   * @param {Object} options
   */
  constructor(vk, [eventId, peer, id]) {
    super(vk);
    this.payload = {
      peer_id: peer,
      id
    };
    this.type = 'removed_messages';
    this.subTypes = [eventId === 13 ? 'delete_messages' : 'restore_messages'];
  }
  /**
   * Checks that messages have been deleted
   *
   * @return {boolean}
   */


  isRemoved() {
    return this.subTypes.includes('delete_messages');
  }
  /**
   * Checks that messages have been restored
   *
   * @return {boolean}
   */


  isRecovery() {
    return this.subTypes.includes('restore_messages');
  }
  /**
   * Returns the identifier of the message
   *
   * @return {string}
   */


  getId() {
    return this.payload.id;
  }
  /**
   * Returns the peer ID
   *
   * @return {number}
   */


  getPeerId() {
    return this.payload.peer_id;
  }

}

const {
  URL: URL$8,
  URLSearchParams: URLSearchParams$6
} = nodeUrl;
const {
  inspect: inspect$11,
  promisify: promisify$2
} = nodeUtil;
const {
  NEED_RESTART,
  POLLING_REQUEST_FAILED
} = updatesErrors;
const debug$8 = createDebug('vk-io:updates');
/**
 * Version polling
 *
 * @type {number}
 */

const POLLING_VERSION = 3;
const webhookContextsEvents = [[['message_new', 'message_edit', 'message_reply'], MessageContext], [['message_allow', 'message_deny'], MessageAllowContext], [['photo_new', 'audio_new', 'video_new'], NewAttachmentsContext], [['wall_post_new', 'wall_repost'], WallPostContext], [['group_join', 'group_leave'], GroupMemberContext], [['user_block', 'user_unblock'], GroupUserContext], [['photo_comment_new', 'photo_comment_edit', 'photo_comment_delete', 'photo_comment_restore', 'video_comment_new', 'video_comment_edit', 'video_comment_delete', 'video_comment_restore', 'wall_reply_new', 'wall_reply_edit', 'wall_reply_delete', 'wall_reply_restore', 'board_reply_new', 'board_reply_edit', 'board_reply_delete', 'board_reply_restore', 'market_reply_new', 'market_reply_edit', 'market_reply_delete', 'market_reply_restore'], CommentActionContext], [['poll_vote_new'], VoteContext], [['group_change_photo', 'group_officers_edit', 'group_change_settings'], GroupUpdateContext]];
const pollingContextsEvents = [[[1, 2, 3], MessageFlagsContext], [[4, 5], MessageContext], [[6, 7], ReadMessagesContext], [[8, 9], UserOnlineContext], [[10, 11, 12], DialogFlagsContext], [[13, 14], RemovedMessagesContext], [[61, 62], TypingContext]];
const webhookContexts = Object.assign({}, ...webhookContextsEvents.map(([events, Context$$1]) => Object.assign({}, ...events.map(event => ({
  [event]: Context$$1
})))));
const pollingContexts = Object.assign({}, ...pollingContextsEvents.map(([events, Context$$1]) => Object.assign({}, ...events.map(event => ({
  [event]: Context$$1
})))));
class Updates {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.restarted = 0;
    this.started = null;
    this.url = null;
    this.ts = null;
    this.pts = null;
    /**
     * 2 -  Attachments
     * 8 -  Extended events
     * 64 - Online user platform ID
     *
     * @type {number}
     */

    this.mode = 2 | 8 | 64;
    this.webhookServer = null;
    this.stack = [];
    this.middleware = null;
    this.hears = new Middleware();

    this.hearFallbackHandler = (context, next) => next();

    this.reloadMiddleware();
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Updates';
  }
  /**
   * Checks is started
   *
   * @return {boolean}
   */


  isStarted() {
    return this.started !== null;
  }
  /**
   * Added middleware
   *
   * @param {Function} handler
   *
   * @return {this}
   */


  use(middleware) {
    this.stack.push(middleware);
    this.reloadMiddleware();
    return this;
  }
  /**
   * Subscribe to events
   *
   * @param {string[]} events
   * @param {Function} handler
   *
   * @return {this}
   */


  on(events, handler) {
    if (!Array.isArray(events)) {
      events = [events];
    }

    const hasNull = events.some(event => !event);

    if (hasNull) {
      throw new Error('Events should be not null');
    }

    return this.use(async (context, next) => {
      if (context.is(events)) {
        await handler(context, next);
        return;
      }

      await next();
    });
  }
  /**
   * Listen text
   *
   * @param {Mixed[]}  condition
   * @param {Function} handler
   *
   * @return {this}
   */


  hear(conditions, handler) {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }

    const hasNull = conditions.some(condition => !condition);

    if (hasNull) {
      throw new Error('Condition should be not null');
    }

    this.hears.use(async (context, next) => {
      const text = context.getText();
      const hasSome = conditions.some(condition => {
        if (typeof condition === 'function') {
          return condition(text, context);
        }

        if (condition instanceof RegExp) {
          const passed = condition.test(text);

          if (passed) {
            context.$match = text.match(condition);
          }

          return passed;
        }

        return text === condition;
      });

      if (!hasSome) {
        await next();
        return;
      }

      await handler(context, next);
    });
    return this;
  }
  /**
   * A handler that is called when handlers are not found
   *
   * @param {Function} handler
   *
   * @return {this}
   */


  setHearFallbackHandler(handler) {
    this.hearFallbackHandler = handler;
    return this;
  }
  /**
   * Handles longpoll event
   *
   * @param {Array} update
   */


  handlePollingUpdate(update) {
    debug$8('longpoll update', update);
    const [type] = update;
    const Context$$1 = pollingContexts[type];

    if (!Context$$1) {
      debug$8(`Unsupported polling context type ${type}`);
      return null;
    }

    return this.dispatchMiddleware(new Context$$1(this.vk, update, {
      source: updatesSources.POLLING,
      updateType: type
    }));
  }
  /**
   * Handles webhook event
   *
   * @param {Object} update
   */


  handleWebhookUpdate(update) {
    debug$8('webhook update', update);
    const {
      type,
      object: payload,
      group_id: groupId
    } = update;
    const Context$$1 = webhookContexts[type];

    if (!Context$$1) {
      debug$8(`Unsupported webhook context type ${type}`);
      return null;
    }

    return this.dispatchMiddleware(new Context$$1(this.vk, payload, {
      source: updatesSources.WEBHOOK,
      updateType: type,
      groupId
    }));
  }
  /**
   * Starts to poll server
   *
   * @return {Promise}
   */


  async startPolling() {
    if (this.started !== null) {
      debug$8(`Updates already started: ${this.started}`);
      return;
    }

    this.started = 'polling';

    try {
      const {
        pollingGroupId
      } = this.vk.options;
      const isGroup = pollingGroupId !== null;
      const {
        server,
        key,
        ts
      } = isGroup ? await this.vk.api.groups.getLongPollServer({
        group_id: pollingGroupId
      }) : await this.vk.api.messages.getLongPollServer({
        lp_version: POLLING_VERSION
      });

      if (this.ts === null) {
        this.ts = ts;
      }

      const pollingURL = isGroup ? server : `https://${server}`;
      this.url = new URL$8(pollingURL);
      this.url.search = new URLSearchParams$6({
        act: 'a_check',
        version: POLLING_VERSION,
        wait: 25,
        key
      });
      this.startFetchLoop();
    } catch (error) {
      this.started = null;
      throw error;
    }
  }
  /**
   * Starts the webhook server
   *
   * @param {Function} next
   *
   * @return {Promise}
   */


  async startWebhook({
    tls,
    path,
    port,
    host
  } = {}, next) {
    if (this.started !== null) {
      debug$8(`Updates already started: ${this.started}`);
      return;
    }

    this.started = 'webhook';

    try {
      const {
        webhookPath
      } = this.vk.options;
      const webhookCallback = this.getWebhookCallback(path || webhookPath || '/');
      const callback = typeof next === 'function' ? (req, res) => webhookCallback(req, res, () => next(req, res)) : webhookCallback;
      this.webhookServer = tls ? nodeHttps.createServer(tls, callback) : nodeHttp.createServer(callback);

      if (!port) {
        port = tls ? 443 : 80;
      }

      const {
        webhookServer
      } = this;
      const listen = promisify$2(webhookServer.listen).bind(webhookServer);
      await listen(port, host);
      debug$8(`Webhook listening on port: ${port}`);
    } catch (error) {
      this.started = null;
      throw error;
    }
  }
  /**
   * Stopping gets updates
   *
   * @return {Promise}
   */


  async stop() {
    this.started = null;
    this.restarted = 0;

    if (this.webhookServer !== null) {
      const {
        webhookServer
      } = this;
      const close = promisify$2(webhookServer.close).bind(webhookServer);
      await close();
      this.webhookServer = null;
    }
  }
  /**
   * Returns webhook callback like http[s] or express
   *
   * @param {string} path
   *
   * @return {Function}
   */


  getWebhookCallback(path = null) {
    return (req, res, next) => {
      if (req.method !== 'POST' || path !== null && req.url !== path) {
        if (typeof next === 'function') {
          next();
          return;
        }

        res.writeHead(403);
        res.end();
        return;
      }

      let body = '';
      req.on('data', chunk => {
        if (body.length > 1e6) {
          body = null;
          res.writeHead(413);
          res.end();
          req.connection.destroy();
          return;
        }

        body += String(chunk);
      });
      req.on('end', () => {
        try {
          const update = JSON.parse(body);
          const {
            webhookSecret,
            webhookConfirmation
          } = this.vk.options;

          if (webhookSecret !== null && update.secret !== webhookSecret) {
            res.writeHead(403);
            res.end();
            return;
          }

          const headers = {
            connection: 'keep-alive',
            'content-type': 'text/plain'
          };

          if (update.type === 'confirmation') {
            if (webhookConfirmation === null) {
              res.writeHead(500);
              res.end();
              return;
            }

            res.writeHead(200, headers);
            res.end(String(webhookConfirmation));
            return;
          }

          res.writeHead(200, headers);
          res.end('ok');
          this.handleWebhookUpdate(update).catch(error => {
            // eslint-disable-next-line no-console
            console.error('Handle webhook update error', error);
          });
        } catch (error) {
          debug$8('webhook error', error);
          res.writeHead(415);
          res.end();
        }
      });
    };
  }
  /**
   * Returns the middleware for the webhook under koa
   *
   * @param {Object} options
   *
   * @return {Function}
   */


  getKoaWebhookMiddleware(options = {}) {
    return async (context, next) => {
      const update = context.request.body;
      const {
        webhookSecret,
        webhookConfirmation
      } = this.vk.options;

      if (webhookSecret !== null && update.secret !== webhookSecret) {
        context.status = 403;
        return;
      }

      if (update.type === 'confirmation') {
        if (webhookConfirmation === null) {
          context.status = 500;
          return;
        }

        context.body = webhookConfirmation;
        return;
      }

      context.body = 'ok';
      context.set('connection', 'keep-alive');
      /* Do not delay server response */

      this.handleWebhookUpdate(update).catch(error => {
        // eslint-disable-next-line no-console
        console.error('Handle webhook update error', error);
      });
    };
  }
  /**
   * Starts forever fetch updates  loop
   *
   * @return {Promise}
   */


  async startFetchLoop() {
    try {
      while (this.started === 'polling') {
        await this.fetchUpdates();
      }
    } catch (error) {
      debug$8('longpoll error', error);
      const {
        pollingWait,
        pollingAttempts
      } = this.vk.options;

      if (error.code !== NEED_RESTART && this.restarted < pollingAttempts) {
        this.restarted += 1;
        debug$8('longpoll restart request');
        await delay(3e3);
        this.startFetchLoop();
        return;
      }

      while (this.started === 'polling') {
        try {
          await this.stop();
          await this.startPolling();
          break;
        } catch (restartError) {
          debug$8('longpoll restarted error', restartError);
          this.started = 'polling';
          await delay(pollingWait);
        }
      }
    }
  }
  /**
   * Gets updates
   *
   * @return {Promise}
   */


  async fetchUpdates() {
    const {
      agent
    } = this.vk.options;
    const {
      searchParams
    } = this.url;
    searchParams.set('ts', this.ts);
    searchParams.set('mode', this.mode);
    debug$8('http -->');
    let response = await fetch(this.url, {
      agent,
      method: 'GET',
      timeout: 30e3,
      compress: false,
      headers: {
        connection: 'keep-alive'
      }
    });
    debug$8(`http <-- ${response.status}`);

    if (!response.ok) {
      throw new UpdatesError({
        code: POLLING_REQUEST_FAILED,
        message: 'Polling request failed'
      });
    }

    response = await response.json();
    this.restarted = 0;

    if ('failed' in response && response.failed !== 1) {
      this.ts = null;
      throw new UpdatesError({
        code: NEED_RESTART,
        message: 'The server has failed'
      });
    }

    this.ts = Number(response.ts);

    if ('pts' in response && response.pts !== this.pts) {
      this.pts = Number(response.pts);
    }

    if ('updates' in response) {
      const isGroup = this.vk.options.pollingGroupId !== null;
      /* Async handle updates */

      Promise.all(response.updates.map(async update => {
        try {
          if (isGroup) {
            await this.handleWebhookUpdate(update);
          } else {
            await this.handlePollingUpdate(update);
          }
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error('Handle polling update error:', error);
        }
      }));
    }
  }
  /**
   * Calls up the middleware chain
   *
   * @param {Context} context
   *
   * @return {Promise<void>}
   */


  dispatchMiddleware(context) {
    return this.middleware.run(context);
  }
  /**
   * Reloads middleware
   */


  reloadMiddleware() {
    this.middleware = new Middleware(this.stack);
    this.middleware.use(async (context, next) => {
      if (!context.is('text')) {
        await next();
        return;
      }

      const {
        finished
      } = await this.hears.run(context);

      if (finished) {
        await this.hearFallbackHandler(context, next);
      }
    });
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$11.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      handlers
    } = this;
    const payload = {
      started,
      handlers
    };
    return `${options.stylize(name, 'special')} ${inspect$11(payload, options)}`;
  }

}

const {
  URL: URL$9
} = nodeUrl;
const {
  INVALID_URL,
  URL_NOT_ALLOWED,
  RESOURCE_NOT_FOUND
} = snippetsErrors;
/**
 * Remove search param
 *
 * @type {RegExp}
 */

const removeSearchParam = /(\?|&)[^=]+=/;
/**
 * Search dot
 *
 * @type {RegExp}
 */

const searchDot = /\./g;
/**
 * Switch resource types
 *
 * @type {Object}
 */

const enumResourceTypes = {
  id: 'user',
  club: 'group',
  public: 'group',
  app: 'application'
};
/**
 * Allowed host names
 *
 * @type {Array}
 */

const allowedHostnames = ['vk.com', 'm.vk.com'];
/**
 * Resolve the attachment resource
 *
 * @param {string} resource
 * @param {RegExp} pattern
 *
 * @return {Object}
 */

const resolveOwnerResource = (resource, pattern) => {
  const [, type, owner, id] = resource.match(pattern);
  return {
    id: Number(id),
    owner: Number(owner),
    type: type.toLowerCase().replace(removeSearchParam, '')
  };
};

class Snippets {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Snippets';
  }
  /**
   * Defines the type of object (user, community, application, attachment)
   *
   * @param {string} resource
   *
   * @return {Promise<Object>}
   */


  async resolveResource(resource) {
    if (!resource) {
      throw new Error('Resource should must be');
    }

    resource = String(resource);

    if (resource.startsWith('@') || resource.startsWith('*')) {
      resource = resource.substring(1);
    }

    const numberResource = Number(resource);
    const resourceIsNaN = Number.isNaN(numberResource);

    if (!resourceIsNaN) {
      const isUser = numberResource > 0;
      return {
        id: isUser ? numberResource : -numberResource,
        type: isUser ? 'user' : 'group'
      };
    }

    let resourceSearch;

    try {
      if (!resource.match(searchDot)) {
        throw new Error('Is not URL');
      }

      let url = resource;

      if (!(url.startsWith('http://') || url.startsWith('https://'))) {
        url = `https://${resource}`;
      }

      const {
        hostname,
        pathname,
        search
      } = new URL$9(url);

      if (!allowedHostnames.includes(hostname)) {
        throw new SnippetsError({
          code: URL_NOT_ALLOWED,
          message: 'URL not allowed'
        });
      }

      if (pathname === '/') {
        throw new SnippetsError({
          code: INVALID_URL,
          message: 'URL should contain path'
        });
      }

      resource = pathname.substring(1);
      resourceSearch = search;
    } catch (error) {
      if ([URL_NOT_ALLOWED, INVALID_URL].includes(error.code)) {
        throw error;
      }
    }

    if (parseAttachment.test(resourceSearch)) {
      return resolveOwnerResource(resourceSearch, parseAttachment);
    }

    if (parseOwnerResource.test(resourceSearch)) {
      return resolveOwnerResource(resourceSearch, parseOwnerResource);
    }

    if (parseAttachment.test(resource)) {
      return resolveOwnerResource(resource, parseAttachment);
    }

    if (parseOwnerResource.test(resource)) {
      return resolveOwnerResource(resource, parseOwnerResource);
    }

    if (parseResource.test(resource)) {
      const [, typeResource, id] = resource.match(parseResource);
      let type = typeResource.toLowerCase();

      if (type in enumResourceTypes) {
        // eslint-disable-next-line prefer-destructuring
        type = enumResourceTypes[type];
      }

      return {
        id: Number(id),
        type
      };
    }

    const response = await this.vk.api.utils.resolveScreenName({
      screen_name: resource
    });

    if (Array.isArray(response)) {
      throw new SnippetsError({
        message: 'Resource not found',
        code: RESOURCE_NOT_FOUND
      });
    }

    const {
      type,
      object_id: id
    } = response;

    if (type === 'page') {
      return {
        id,
        type: 'group'
      };
    }

    return {
      id,
      type
    };
  }

}

const {
  URL: URL$10,
  URLSearchParams: URLSearchParams$7
} = nodeUrl;
const {
  inspect: inspect$12,
  promisify: promisify$3
} = nodeUtil;
const debug$9 = createDebug('vk-io:streaming');
class StreamingAPI {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.key = null;
    this.socket = null;
    this.endpoint = null;
    this.started = null;
    this.handlers = [];
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'StreamingAPI';
  }
  /**
   * Starts websocket
   *
   * @return {Promise}
   */


  async startWebSocket() {
    this.started = 'websocket';

    try {
      const {
        key,
        endpoint
      } = await this.vk.api.streaming.getServerUrl();
      this.key = key;
      this.endPoint = new URL$10(`https://${endpoint}`);
      const search = new URLSearchParams$7({
        key
      });
      const {
        agent
      } = this.vk.options;
      this.socket = new WebSocket(`wss://${endpoint}/stream?${search}`, {
        agent
      });
    } catch (error) {
      this.started = null;
      throw error;
    }

    const {
      socket
    } = this;
    this.close = promisify$3(socket.close).bind(socket);
    socket.on('message', data => {
      let message;

      try {
        message = JSON.parse(data);
      } catch (error) {
        debug$9('JSON parse failed', error);
        return;
      }

      const {
        code
      } = message;

      try {
        switch (code) {
          case 100:
            {
              this.handleEvent(message.event);
              break;
            }

          case 300:
            {
              this.handleServiceMessage(message.service_message);
              break;
            }

          default:
            debug$9(`Unsupported message code: ${code}`);
        }
      } catch (error) {
        // eslint-disable-next-line no-console
        console.log('Handle event error', error);
      }
    });
    socket.on('error', error => {
      debug$9('WebSocket error', error);
    });
  }
  /**
   * Stop all connection
   *
   * @return {Promise}
   */


  async stop() {
    if (this.started === null) {
      return;
    }

    await this.close();
    this.started = null;
    this.key = null;
    this.socket = null;
    this.endpoint = null;
  }
  /**
   * Processes server messages
   *
   * @param {Object} serviceMessage
   *
   * @return {Promise}
   */


  async handleServiceMessage({
    message,
    service_code: code
  }) {
    if ([3000, 3001].includes(code)) {
      await this.stop();
      await this.start();
    }
  }
  /**
   * Handles events
   *
   * @param {Object} event
   *
   * @return {Promise}
   */


  async handleEvent(event) {
    const context = new StreamingContext(this.vk, event);
    return await this.vk.updates.dispatchMiddleware(context);
  }
  /**
   * Executes the HTTP request for rules
   *
   * @param {string} method
   * @param {Object} options
   *
   * @return {Promise<Object>}
   */


  async fetchRules(method, payload = {}) {
    const {
      agent
    } = this.vk.options;
    const url = new URL$10('/rules', this.endPoint);
    url.searchParams.set('key', this.key);
    let body;

    if (method !== 'GET') {
      body = JSON.stringify(payload);
    }

    let response = await fetch(url, {
      agent,
      method,
      body,
      headers: {
        'content-type': 'application/json'
      }
    });
    response = await response.json();

    if ('error' in response) {
      throw new StreamingRuleError(response.error);
    }

    return response;
  }
  /**
   * Returns a list of rules
   *
   * @return {Promise<Array>}
   */


  async getRules() {
    const {
      rules = []
    } = await this.fetchRules('GET');
    return rules;
  }
  /**
   * Adds a rule
   *
   * @param {Object} rule
   *
   * @return {Promise}
   */


  addRule(rule) {
    return this.fetchRules('POST', {
      rule
    });
  }
  /**
   * Removes the rule
   *
   * @param {string} tag
   *
   * @return {Promise}
   */


  deleteRule(tag) {
    return this.fetchRules('DELETE', {
      tag
    });
  }
  /**
   * Adds a list of rules
   *
   * @param {Array} rules
   *
   * @return {Promise}
   */


  addRules(rules) {
    return Promise.all(rules.map(rule => this.addRule(rule)));
  }
  /**
   * Removes all rules
   *
   * @return {Promise}
   */


  async deleteRules() {
    const rules = await this.getRules();
    return await Promise.all(rules.map(({
      tag
    }) => this.deleteRule(tag)));
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$12.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      handlers
    } = this;
    const payload = {
      started,
      handlers
    };
    return `${options.stylize(name, 'special')} ${inspect$12(payload, options)}`;
  }

}

const {
  Agent
} = nodeHttps;
const {
  inspect: inspect$13
} = nodeUtil;
/**
 * Main class
 *
 * @public
 */

class VK {
  /**
   * Constructor
   *
   * @param {Object} options
   */
  constructor(options = {}) {
    this.options = _objectSpread({}, defaultOptions, {
      agent: new Agent({
        keepAlive: true,
        keepAliveMsecs: 10000
      })
    });
    this.setOptions(options);
    this.api = new API(this);
    this.auth = new Auth(this);
    this.upload = new Upload(this);
    this.collect = new Collect(this);
    this.updates = new Updates(this);
    this.snippets = new Snippets(this);
    this.streaming = new StreamingAPI(this);
    this.captchaHandler = null;
    this.twoFactorHandler = null;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'VK';
  }
  /**
   * Sets options
   *
   * @param {Object} options
   *
   * @return {this}
   */


  setOptions(options) {
    Object.assign(this.options, options);
    return this;
  }
  /**
   * Sets token
   *
   * @param {string} token
   *
   * @return {this}
   */


  setToken(token) {
    this.options.token = token;
    return this;
  }
  /**
   * Returns token
   *
   * @return {?string}
   */


  getToken() {
    return this.options.token;
  }
  /**
   * Sets captcha handler
   *
   * @param {?Function} handler
   *
   * @return {this}
   *
   * @example
   * 	vk.setCaptchaHandler((payload, retry) => {...});
   */


  setCaptchaHandler(handler) {
    this.captchaHandler = handler;
    return this;
  }
  /**
   * Sets two-factor handler
   *
   * @param {?Function} handler
   *
   * @return {this}
   *
   * @example
   * 	vk.setTwoFactorHandler((payload, retry) => {...});
   */


  setTwoFactorHandler(handler) {
    this.twoFactorHandler = handler;
    return this;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$13.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      api,
      updates,
      streaming,
      captchaHandler,
      twoFactorHandler
    } = this;
    const {
      app,
      token,
      login,
      phone
    } = this.options;
    const payload = {
      options: {
        app,
        login,
        phone,
        token
      },
      captchaHandler,
      twoFactorHandler,
      api,
      updates,
      streaming
    };
    return `${options.stylize(name, 'special')} ${inspect$13(payload, options)}`;
  }

}

exports.VK = VK;
exports.Request = Request;
exports.default = VK;
exports.captchaTypes = captchaTypes;
exports.VKError = VKError;
exports.APIError = APIError;
exports.AuthError = AuthError;
exports.UploadError = UploadError;
exports.CollectError = CollectError;
exports.UpdatesError = UpdatesError;
exports.ExecuteError = ExecuteError;
exports.SnippetsError = SnippetsError;
exports.StreamingRuleError = StreamingRuleError;
exports.apiErrors = apiErrors;
exports.authErrors = authErrors;
exports.uploadErrors = uploadErrors;
exports.updatesErrors = updatesErrors;
exports.collectErrors = collectErrors;
exports.snippetsErrors = snippetsErrors;
exports.Context = Context;
exports.VoteContext = VoteContext;
exports.TypingContext = TypingContext;
exports.MessageContext = MessageContext;
exports.WallPostContext = WallPostContext;
exports.StreamingContext = StreamingContext;
exports.GroupUserContext = GroupUserContext;
exports.UserOnlineContext = UserOnlineContext;
exports.GroupUpdateContext = GroupUpdateContext;
exports.DialogFlagsContext = DialogFlagsContext;
exports.MessageAllowContext = MessageAllowContext;
exports.GroupMemberContext = GroupMemberContext;
exports.ReadMessagesContext = ReadMessagesContext;
exports.MessageFlagsContext = MessageFlagsContext;
exports.CommentActionContext = CommentActionContext;
exports.NewAttachmentsContext = NewAttachmentsContext;
exports.RemovedMessagesContext = RemovedMessagesContext;
exports.Attachment = Attachment;
exports.ExternalAttachment = ExternalAttachment;
exports.GiftAttachment = GiftAttachment;
exports.WallAttachment = WallAttachment;
exports.LinkAttachment = LinkAttachment;
exports.PhotoAttachment = PhotoAttachment;
exports.AudioAttachment = AudioAttachment;
exports.VideoAttachment = VideoAttachment;
exports.MarketAttachment = MarketAttachment;
exports.StickerAttachment = StickerAttachment;
exports.DocumentAttachment = DocumentAttachment;
exports.WallReplyAttachment = WallReplyAttachment;
exports.MarketAlbumAttachment = MarketAlbumAttachment;
